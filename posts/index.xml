<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Insidehand</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Insidehand</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Mon, 07 Jul 2025 05:10:33 +0800</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Mobkins Support</title>
            <link>/posts/apps/mobkins/support/</link>
            <pubDate>Mon, 07 Jul 2025 05:10:33 +0800</pubDate>
            
            <guid>/posts/apps/mobkins/support/</guid>
            <description>Support information for Mobkins</description>
            <content type="html"><![CDATA[<h2 id="mobkins-support">Mobkins Support</h2>
<p>Thank you for using <strong>Mobkins</strong>, an iOS app designed to help you manage your Jenkins builds directly from your iPhone.</p>
<h3 id="contact">Contact</h3>
<p>If you have any questions, feature requests, or bug reports, feel free to contact us:</p>
<ul>
<li>Email: <a href="mailto:requestflow@gmail.com">requestflow@gmail.com</a></li>
</ul>
<h3 id="frequently-asked-questions">Frequently Asked Questions</h3>
<p><strong>Q: Does Mobkins collect any personal data?</strong><br>
A: No. Mobkins does not collect, store, or transmit any personal data to us. All connections are made directly between your device and the Jenkins server you specify.</p>
<p><strong>Q: My Jenkins server requires login. Does Mobkins support authentication?</strong><br>
A: Yes. You can provide your username and API token/password directly within the app to connect securely to your Jenkins server.</p>
<p><strong>Q: Is Mobkins an official Jenkins app?</strong><br>
A: No. Mobkins is an independent app and not affiliated with or endorsed by the Jenkins project.</p>
<hr>
<h2 id="mobkins-支援說明">Mobkins 支援說明</h2>
<p>感謝您使用 <strong>Mobkins</strong>，這是一款幫助您從 iPhone 管理 Jenkins 建置流程的 iOS 應用程式。</p>
<h3 id="聯絡方式">聯絡方式</h3>
<p>如果您有任何問題、功能建議或錯誤回報，歡迎透過以下方式聯絡我們：</p>
<ul>
<li>電子郵件：<a href="mailto:requestflow@gmail.com">requestflow@gmail.com</a></li>
</ul>
<h3 id="常見問題">常見問題</h3>
<p><strong>問：Mobkins 會蒐集個人資料嗎？</strong><br>
答：不會。Mobkins 不會向我們蒐集、儲存或傳送任何個人資料。所有連線僅在您的裝置與您所指定的 Jenkins 伺服器之間進行。</p>
<p><strong>問：我的 Jenkins 伺服器需要登入，Mobkins 支援身份驗證嗎？</strong><br>
答：支援。您可以在 App 中提供帳號與 API Token 或密碼，安全地連線至您的 Jenkins 伺服器。</p>
<p><strong>問：Mobkins 是官方的 Jenkins App 嗎？</strong><br>
答：不是。Mobkins 是獨立開發的應用程式，並未獲得 Jenkins 官方的認可或授權。</p>
]]></content>
        </item>
        
        <item>
            <title>Mobkins privacy term</title>
            <link>/posts/apps/mobkins/privacy_policy/</link>
            <pubDate>Mon, 07 Jul 2025 04:52:33 +0800</pubDate>
            
            <guid>/posts/apps/mobkins/privacy_policy/</guid>
            <description>Mobkins Privacy Term</description>
            <content type="html"><![CDATA[<h2 id="privacy-policy--隱私條款">Privacy Policy / 隱私條款</h2>
<p><strong>Last updated: 2025-07-07</strong></p>
<h3 id="english">English</h3>
<p>Mobkins does not collect, store, or transmit any personal data to us.<br>
The app connects only to Jenkins servers that you configure, and all data communication happens directly between your device and your own server.<br>
We do not use analytics, advertising, or tracking tools.<br>
Your server information is stored only on your device and is never shared with us.</p>
<p>If you have any questions, feel free to contact us.</p>
<h3 id="中文">中文</h3>
<p>Mobkins 不會向我們蒐集、儲存或傳送任何個人資料。<br>
本應用程式僅會連線至您所設定的 Jenkins 伺服器，所有資料傳輸皆在您的裝置與您的伺服器之間進行。<br>
我們不使用任何分析工具、廣告服務或追蹤技術。<br>
您的伺服器資訊僅保留在您的裝置上，絕不會與我們分享。</p>
<p>若您有任何疑問，歡迎與我們聯繫。</p>
]]></content>
        </item>
        
        <item>
            <title>如何把Server只開放給SSH RSA登入</title>
            <link>/posts/2024-01-05-ssh-only-via-rsa/</link>
            <pubDate>Sat, 20 Jan 2024 23:47:08 +0800</pubDate>
            
            <guid>/posts/2024-01-05-ssh-only-via-rsa/</guid>
            <description>&lt;p&gt;大家都知道，讓明碼在網路上傳輸是很危險的，所以我們都會使用SSH RSA登入，但是如果你的Server是直接連上網路的話，那麼你的Server就會被駭客不斷的嘗試登入，這時候你就可以使用下面的方法，讓你的Server只開放給SSH RSA登入。&lt;/p&gt;
&lt;p&gt;原則上有幾個步驟要處理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;加入SSH公鑰（不然一開始就封閉，除非Server有可以直接操作的螢幕，不然就再也沒辦法控制了）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;具體加入的方法可以參考&lt;a href=&#34;/posts/2020-06-28-ssh-basic-setup/&#34;&gt;這篇&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設定防火牆，只開放特定的IP可以連線&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設定SSH，只開放RSA登入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重啟SSH&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;step2-設定防火牆只開放特定的ip可以連線&#34;&gt;Step2. 設定防火牆，只開放特定的IP可以連線&lt;/h2&gt;
&lt;p&gt;使用編輯器修改下面兩個檔案，並且加入新的設定&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/hosts.allow&lt;/code&gt;
&lt;code&gt;/etc/hosts.deny&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# /etc/hosts.allow&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/etc/hosts.allow
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 允許所有本地IP（記得修改網段，未必每個人都是192.168.50.xx）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sshd: 192.168.50.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# /etc/hosts.deny&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 禁止所有來源 IP 的連線&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sshd: ANY
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;step3-設定ssh只開放rsa登入&#34;&gt;Step3. 設定SSH，只開放RSA登入&lt;/h2&gt;
&lt;p&gt;使用編輯器修改下面檔案，並且加入新的設定&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# /etc/ssh/sshd_config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PubkeyAuthentication yes
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;PasswordAuthentication no
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;step4-重啟ssh&#34;&gt;Step4. 重啟SSH&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo /etc/init.d/ssh restart
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://officeguide.cc/linux-hosts-allow-deny-restrict-ip-address-tutorial-examples/&#34;&gt;https://officeguide.cc/linux-hosts-allow-deny-restrict-ip-address-tutorial-examples/&lt;/a&gt;&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>大家都知道，讓明碼在網路上傳輸是很危險的，所以我們都會使用SSH RSA登入，但是如果你的Server是直接連上網路的話，那麼你的Server就會被駭客不斷的嘗試登入，這時候你就可以使用下面的方法，讓你的Server只開放給SSH RSA登入。</p>
<p>原則上有幾個步驟要處理</p>
<ol>
<li>
<p>加入SSH公鑰（不然一開始就封閉，除非Server有可以直接操作的螢幕，不然就再也沒辦法控制了）</p>
<blockquote>
<p>具體加入的方法可以參考<a href="/posts/2020-06-28-ssh-basic-setup/">這篇</a></p></blockquote>
</li>
<li>
<p>設定防火牆，只開放特定的IP可以連線</p>
</li>
<li>
<p>設定SSH，只開放RSA登入</p>
</li>
<li>
<p>重啟SSH</p>
</li>
</ol>
<h2 id="step2-設定防火牆只開放特定的ip可以連線">Step2. 設定防火牆，只開放特定的IP可以連線</h2>
<p>使用編輯器修改下面兩個檔案，並且加入新的設定</p>
<p><code>/etc/hosts.allow</code>
<code>/etc/hosts.deny</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># /etc/hosts.allow</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/etc/hosts.allow
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 允許所有本地IP（記得修改網段，未必每個人都是192.168.50.xx）</span>
</span></span><span style="display:flex;"><span>sshd: 192.168.50.
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># /etc/hosts.deny</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 禁止所有來源 IP 的連線</span>
</span></span><span style="display:flex;"><span>sshd: ANY
</span></span></code></pre></div><h2 id="step3-設定ssh只開放rsa登入">Step3. 設定SSH，只開放RSA登入</h2>
<p>使用編輯器修改下面檔案，並且加入新的設定</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># /etc/ssh/sshd_config</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PubkeyAuthentication yes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PasswordAuthentication no
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span></code></pre></div><h2 id="step4-重啟ssh">Step4. 重啟SSH</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo /etc/init.d/ssh restart
</span></span></code></pre></div><h2 id="參考資料">參考資料</h2>
<p><a href="https://officeguide.cc/linux-hosts-allow-deny-restrict-ip-address-tutorial-examples/">https://officeguide.cc/linux-hosts-allow-deny-restrict-ip-address-tutorial-examples/</a></p>
]]></content>
        </item>
        
        <item>
            <title>關於Object Oriented Programming的那點事 1</title>
            <link>/posts/2024-01-16-oop1/</link>
            <pubDate>Tue, 16 Jan 2024 11:17:00 +0800</pubDate>
            
            <guid>/posts/2024-01-16-oop1/</guid>
            <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;會寫這篇是因為在工作了幾年之後，發現很多人都不知道什麼是OOP，也不知道OOP的好處。常常會看到重複的程式碼，或是程式碼的可讀性很差。&lt;/p&gt;
&lt;p&gt;基於取之於社群，用之於社群的精神，想寫一些關於OOP的文章
希望能夠幫助到一些人，也在寫文章的時候釐清一下自己的想法。&lt;/p&gt;
&lt;h2 id=&#34;什麼是oop-&#34;&gt;什麼是OOP ?&lt;/h2&gt;
&lt;p&gt;OOP是Object Oriented Programming的縮寫，中文翻譯為物件導向程式設計，是一種程式設計的方法論，這種方法論的核心是將程式中的資料與操作資料的程式碼封裝成一個個的物件，並且透過物件之間的互動來完成程式的功能。&lt;/p&gt;
&lt;h2 id=&#34;物件導向基本原則&#34;&gt;物件導向基本原則&lt;/h2&gt;
&lt;p&gt;物件導向的概念有幾個，分別是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;封裝&lt;/code&gt;: 將資料與操作資料的程式碼隱藏在物件內部，只提供介面給外部使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;繼承&lt;/code&gt;: 將程式碼中相同的部分抽到父物件，讓不同的子物件可以共用，減少重複的程式碼&lt;/li&gt;
&lt;li&gt;&lt;code&gt;多型&lt;/code&gt;: 透過相同的介面來達成不同的實作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SOLID原則是物件導向的五個基本原則，分別是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Single Responsibility Principle&lt;/code&gt;: 一個物件只做一件事&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Open/Closed Principle&lt;/code&gt;: 一個物件應該是可以擴充的，但應該避免修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Liskov Substitution Principle&lt;/code&gt;: 子物件可以替換父物件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Interface Segregation Principle&lt;/code&gt;: 物件之間的互動應該相依於介面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dependency Inversion Principle&lt;/code&gt;: 高階模組不應該依賴低階模組，兩者都應該依賴抽象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;物件導向的目的&#34;&gt;物件導向的目的&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Divide and Conquer. - Caesar&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;這些原則其實最終都指向一個基本想法：「可維護」&lt;/p&gt;
&lt;p&gt;透過這些原則，可以減少重複的程式碼、增加可讀性、並且更容易找到要修改的地方。&lt;/p&gt;</description>
            <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>會寫這篇是因為在工作了幾年之後，發現很多人都不知道什麼是OOP，也不知道OOP的好處。常常會看到重複的程式碼，或是程式碼的可讀性很差。</p>
<p>基於取之於社群，用之於社群的精神，想寫一些關於OOP的文章
希望能夠幫助到一些人，也在寫文章的時候釐清一下自己的想法。</p>
<h2 id="什麼是oop-">什麼是OOP ?</h2>
<p>OOP是Object Oriented Programming的縮寫，中文翻譯為物件導向程式設計，是一種程式設計的方法論，這種方法論的核心是將程式中的資料與操作資料的程式碼封裝成一個個的物件，並且透過物件之間的互動來完成程式的功能。</p>
<h2 id="物件導向基本原則">物件導向基本原則</h2>
<p>物件導向的概念有幾個，分別是：</p>
<ol>
<li><code>封裝</code>: 將資料與操作資料的程式碼隱藏在物件內部，只提供介面給外部使用</li>
<li><code>繼承</code>: 將程式碼中相同的部分抽到父物件，讓不同的子物件可以共用，減少重複的程式碼</li>
<li><code>多型</code>: 透過相同的介面來達成不同的實作</li>
</ol>
<p>SOLID原則是物件導向的五個基本原則，分別是：</p>
<ol>
<li><code>Single Responsibility Principle</code>: 一個物件只做一件事</li>
<li><code>Open/Closed Principle</code>: 一個物件應該是可以擴充的，但應該避免修改</li>
<li><code>Liskov Substitution Principle</code>: 子物件可以替換父物件</li>
<li><code>Interface Segregation Principle</code>: 物件之間的互動應該相依於介面</li>
<li><code>Dependency Inversion Principle</code>: 高階模組不應該依賴低階模組，兩者都應該依賴抽象</li>
</ol>
<h2 id="物件導向的目的">物件導向的目的</h2>
<blockquote>
<p>Divide and Conquer. - Caesar</p></blockquote>
<p>這些原則其實最終都指向一個基本想法：「可維護」</p>
<p>透過這些原則，可以減少重複的程式碼、增加可讀性、並且更容易找到要修改的地方。</p>
]]></content>
        </item>
        
        <item>
            <title>關於Object Oriented Programming的那點事 2</title>
            <link>/posts/2024-01-16-oop2/</link>
            <pubDate>Tue, 16 Jan 2024 11:17:00 +0800</pubDate>
            
            <guid>/posts/2024-01-16-oop2/</guid>
            <description>&lt;h2 id=&#34;實務應用&#34;&gt;實務應用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;基於這篇是在講概念，所以程式碼的部分就寫個意思，並不能真的執行的。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;這裡也不太想要老調重彈的說一些 Duck, Animal, Dog, Cat 的例子，直接來點實務上面的應用，來說明一下物件導向的優點。&lt;/p&gt;
&lt;p&gt;在幾年前，我在一家寫POS系統的公司工作，當時需要列印電子發票，公司找了Epson的印表機的代理商，從他們那邊確定了貨源。&lt;/p&gt;
&lt;p&gt;於是乎，有了以下這段程式碼。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;EpsonPrinterHelper&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; shared = EpsonPrinterHelper()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;() {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 列印發票&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(invoice: Invoice) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; printer = EpsonPrinter()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printer.setText(invoice.title)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printer.setText(invoice.date)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printer.setText(invoice.number)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printer.print()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        printer.cut()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;/// 列印收據&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(receipt: Receipt) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; printer = EpsonPrinter()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ...
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// 結帳頁面&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CheckoutViewController&lt;/span&gt;: UIViewController {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printInvoice&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; invoice = Invoice()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EpsonPrinterHelper.shared.print(invoice: invoice)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printReceipt&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; receipt = Receipt()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        EpsonPrinterHelper.shared.print(receipt: receipt)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這段程式碼運作起來很正常，很美好，直到公司決定要賣其他廠牌印表機的那一天。&lt;/p&gt;</description>
            <content type="html"><![CDATA[<h2 id="實務應用">實務應用</h2>
<blockquote>
<p>基於這篇是在講概念，所以程式碼的部分就寫個意思，並不能真的執行的。</p></blockquote>
<p>這裡也不太想要老調重彈的說一些 Duck, Animal, Dog, Cat 的例子，直接來點實務上面的應用，來說明一下物件導向的優點。</p>
<p>在幾年前，我在一家寫POS系統的公司工作，當時需要列印電子發票，公司找了Epson的印表機的代理商，從他們那邊確定了貨源。</p>
<p>於是乎，有了以下這段程式碼。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EpsonPrinterHelper</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = EpsonPrinterHelper()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">init</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 列印發票</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(invoice: Invoice) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> printer = EpsonPrinter()
</span></span><span style="display:flex;"><span>        printer.setText(invoice.title)
</span></span><span style="display:flex;"><span>        printer.setText(invoice.date)
</span></span><span style="display:flex;"><span>        printer.setText(invoice.number)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        printer.print()
</span></span><span style="display:flex;"><span>        printer.cut()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 列印收據</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(receipt: Receipt) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> printer = EpsonPrinter()
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// 結帳頁面</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CheckoutViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printInvoice</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> invoice = Invoice()
</span></span><span style="display:flex;"><span>        EpsonPrinterHelper.shared.print(invoice: invoice)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printReceipt</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> receipt = Receipt()
</span></span><span style="display:flex;"><span>        EpsonPrinterHelper.shared.print(receipt: receipt)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這段程式碼運作起來很正常，很美好，直到公司決定要賣其他廠牌印表機的那一天。</p>
<p>先來看一下這段程式碼會有什麼問題。由內往外逐步分析</p>
<p><strong>問題一：每一個方法都直接對應一種單據，所以如果要新增一種單據，就要修改這個檔案。</strong></p>
<p>這就是違反了「單一職責」與「開放封閉」，那麼造成的問題呢？這個檔案就會參雜許多不同的異動記錄，有問題會難以追根溯源。</p>
<p>例如</p>
<ul>
<li>修復：「工單_00321」發票QRCode大小異常</li>
<li>新增：「工單_00322」列印打卡記錄</li>
<li>移除：「工單_00323」盤點庫存明細</li>
</ul>
<p>顯然，如果異動記錄是這樣會比較好</p>
<ul>
<li>修復：「工單_00321」發票QRCode大小異常</li>
<li>新增：「工單_00322」發票明細增加商品金額</li>
<li>新增：「工單_00323」發票頂部新增自訂圖片</li>
</ul>
<p>好處一目瞭然：所有的異動都是針對發票，而不是其他要列印的單據。</p>
<blockquote>
<p>commit message 要寫好，不過這個會另外寫一篇文章來講。</p></blockquote>
<p><strong>問題二：列印畫面直接依賴在EpsonPrinter，沒有辦法替換印表機。</strong></p>
<p>這個就是違反「子物件替換」與「介面隔離」。就如同上面的修改，如果每次要新增一個新的印表機類型，就要來修改結帳畫面。但是結帳畫面的「職責」是「整理要結帳資料」而不是選擇印表機</p>
<p>基於上面的問題，於是有了以下的修改版本。</p>
<blockquote>
<p>這段程式碼會有一點長，所以拆開來講解</p></blockquote>
<h4 id="第一步拆分列印任務">第一步：拆分列印任務</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">PrinterTask</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(with printer: Printer)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PrintInvoiceTask</span>: PrinterTask {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> invoice: Invoice
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(with printer: Printer) {
</span></span><span style="display:flex;"><span>        printer.setText(invoice.title)
</span></span><span style="display:flex;"><span>        printer.setText(invoice.date)
</span></span><span style="display:flex;"><span>        printer.setText(invoice.number)
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        printer.print()
</span></span><span style="display:flex;"><span>        printer.cut()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">PrintReceiptTask</span>: PrinterTask {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> receipt: Receipt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(with printer: Printer) {
</span></span><span style="display:flex;"><span>        printer.setText(receipt.title)
</span></span><span style="display:flex;"><span>        printer.setText(receipt.date)
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        printer.print()
</span></span><span style="display:flex;"><span>        printer.cut()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此，就能把不同的列印任務，拆分到不同的類別中。針對檔案的 commit 也能夠更精確地說明修改內容。</p>
<h4 id="第二步高階物件使用抽象介面">第二步：高階物件使用抽象介面</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PrinterHelper</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">let</span> shared = PrinterHelper()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">init</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// 列印</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">print</span>(task: PrinterTask, with: Printer) {
</span></span><span style="display:flex;"><span>       task.print(with: Printer)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>乍看之下感覺這個物件沒什麼用處，只是單純的 <code>Middle Man</code> 。</p>
<p>是因為這邊並沒有引入錯誤處理的流程。</p>
<p>這邊可以另外負責列印任務失敗以後的處理，諸如重印、拋出錯誤、記錄 log 等等，這個物件的職責就會從「處理各種單據」變成「處理列印任務」，這樣職責就細化了。</p>
<h4 id="第三步印表機職責">第三步：印表機職責</h4>
<p>上面的程式碼會發現宣告了一個<code>Printer protocol</code>，但是並沒有實作。因為這邊牽扯到一個稍微複雜的設計，所以放到後面才講。</p>
<p>照一般的寫法，會是這樣的設計</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EpsonPrinter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printInvoice</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printReceipt</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StarPrinter</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printInvoice</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printReceipt</span>
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這樣寫的問題也很明顯，一來程式碼重複性很高，二來兩邊的邏輯就有可能會對不上。有可能發生「修好一個印表機的發票格式，忘了修其他的」。所以這邊需要引入一個 Design Pattern</p>
<p>使用了 <code>Bridge Pattern</code> 改寫以後的程式碼是這樣，將抽象與實作分離</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">Printer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setText</span>(<span style="color:#66d9ef">_</span> text: String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setBarcode</span>(<span style="color:#66d9ef">_</span> text: String)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">setQrcode</span>(<span style="color:#66d9ef">_</span> text: String)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EpsonPrinter</span>: NSObject, EpsonPrinterDelegate, Printer {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StarPrinter</span>: Printer {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>把商業邏輯從物件中去掉，讓Printer只具有基本能力。</p>
<p>如此一來，結帳頁面就可以改寫成這個版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">/// 結帳頁面</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CheckoutViewController</span>: UIViewController {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printInvoice</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> invoice = Invoice(...)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> task = PrintInvoiceTask(invoice: invoice)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> invoicePrinter = PrinterManager.shared.getInvoicePrinter()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        PrinterHelper.shared.print(task: task, invoicePrinter)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">printReceipt</span>() {
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>當然過程中有很多奇奇怪怪的坑要踩，列印流程也不是一次到位，要根據不同的印表機整理出一個共同能使用的基本流程本來就很複雜。</p>
<p>優點也很明顯，後面有新增第三台印表機的時候，可以直接讓印表機實作<code>Printer</code>這個協定，然後<code>PrinterManager</code>這裡面提供這個印表機實體就處理完了。</p>
<p>也不會遇到邏輯不一致的問題，因為邏輯封裝在各種的<code>Task</code>內部。</p>
<h2 id="結論">結論</h2>
<p>物件導向的重點</p>
<p>這樣的流程也是當初慢慢摸索出來的</p>
<p>重點是 <strong>「如果沒有需求，就不要花時間設計」</strong></p>
]]></content>
        </item>
        
        <item>
            <title>善用Protocol與Protocol Extension</title>
            <link>/posts/2024-01-04-protocol-and-extension/</link>
            <pubDate>Thu, 04 Jan 2024 13:47:08 +0800</pubDate>
            
            <guid>/posts/2024-01-04-protocol-and-extension/</guid>
            <description>&lt;p&gt;例如說常在SwiftUI &lt;code&gt;List&lt;/code&gt;, &lt;code&gt;ForEach&lt;/code&gt;裡面用到的&lt;code&gt;Identifiable&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;每次要做比較的時候都要寫一次&lt;code&gt;Equatable&lt;/code&gt;的等價關係&lt;/p&gt;
&lt;p&gt;如果善用&lt;code&gt;protocol extenion&lt;/code&gt;的話，就可以針對大部分的&lt;code&gt;Identifiable&lt;/code&gt;做一個通用的擴充&lt;/p&gt;
&lt;p&gt;所有實作了&lt;code&gt;Identifiable&lt;/code&gt;的對象都可以直接擴充&lt;code&gt;Equatable&lt;/code&gt;，而不用再寫同樣的程式碼&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：這邊只是因為個人開發習慣，所以相同 id 的物件會直接視為相同，
如果開發需要不同的比對方式，請自行修改。切勿照抄。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;舉個例子，如果目前有一個&lt;code&gt;Student&lt;/code&gt;，需要進行比對&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;classs Student: Equatable, Identifiable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; id = UUID()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; name: String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般寫完這段程式碼以後，要自己實作&lt;code&gt;Equatable&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; == (lhs: Student, rhs: Student) -&amp;gt; Bool {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lhs.id == rhs.id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此，才能使用&lt;code&gt;==&lt;/code&gt;來比對兩個物件是否相等。&lt;/p&gt;
&lt;p&gt;不過，&lt;/p&gt;
&lt;p&gt;如果沒有其他情況要特別比對，每次都只是比對&lt;code&gt;id&lt;/code&gt;是否相等，那會產生大量的無用程式碼&lt;/p&gt;
&lt;p&gt;所以這邊就可以用&lt;code&gt;Protocol Extension&lt;/code&gt;來簡化程式碼。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Equatable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;: Identifiable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; == (lhs: &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;, rhs: &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;) -&amp;gt; Bool {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      lhs.id == rhs.id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這樣就可以針對所有實作&lt;code&gt;Equatable&lt;/code&gt;與&lt;code&gt;Identifiable&lt;/code&gt;的物件進行一個預設的擴充。&lt;/p&gt;
&lt;p&gt;如果有不一樣的需求，再自己實作一次介面方法就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UIKit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;: Equatable, Identifiable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: String) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;self&lt;/span&gt;.name = name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; id = UUID()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; name: String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; obj1: Student = .&lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; obj2: Student = .&lt;span style=&#34;color:#66d9ef&#34;&gt;init&lt;/span&gt;(name: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;extension&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Equatable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;: Identifiable {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; == (lhs: &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;, rhs: &lt;span style=&#34;color:#66d9ef&#34;&gt;Self&lt;/span&gt;) -&amp;gt; Bool {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        lhs.id == rhs.id
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(obj1 == obj2) &lt;span style=&#34;color:#75715e&#34;&gt;// return false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//extension Student {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    static func == (lhs: Student, rhs: Student) -&amp;gt; Bool {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//        lhs.name == rhs.name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    }&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//print(obj1 == obj2) // return true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
            <content type="html"><![CDATA[<p>例如說常在SwiftUI <code>List</code>, <code>ForEach</code>裡面用到的<code>Identifiable</code>，</p>
<p>每次要做比較的時候都要寫一次<code>Equatable</code>的等價關係</p>
<p>如果善用<code>protocol extenion</code>的話，就可以針對大部分的<code>Identifiable</code>做一個通用的擴充</p>
<p>所有實作了<code>Identifiable</code>的對象都可以直接擴充<code>Equatable</code>，而不用再寫同樣的程式碼</p>
<blockquote>
<p>注意：這邊只是因為個人開發習慣，所以相同 id 的物件會直接視為相同，
如果開發需要不同的比對方式，請自行修改。切勿照抄。</p></blockquote>
<p>舉個例子，如果目前有一個<code>Student</code>，需要進行比對</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>classs Student: Equatable, Identifiable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> id = UUID()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>一般寫完這段程式碼以後，要自己實作<code>Equatable</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Student</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> == (lhs: Student, rhs: Student) -&gt; Bool {
</span></span><span style="display:flex;"><span>      lhs.id == rhs.id
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此，才能使用<code>==</code>來比對兩個物件是否相等。</p>
<p>不過，</p>
<p>如果沒有其他情況要特別比對，每次都只是比對<code>id</code>是否相等，那會產生大量的無用程式碼</p>
<p>所以這邊就可以用<code>Protocol Extension</code>來簡化程式碼。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Equatable</span> <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">Self</span>: Identifiable {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> == (lhs: <span style="color:#66d9ef">Self</span>, rhs: <span style="color:#66d9ef">Self</span>) -&gt; Bool {
</span></span><span style="display:flex;"><span>      lhs.id == rhs.id
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>這樣就可以針對所有實作<code>Equatable</code>與<code>Identifiable</code>的物件進行一個預設的擴充。</p>
<p>如果有不一樣的需求，再自己實作一次介面方法就可以了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">import</span> <span style="color:#a6e22e">UIKit</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span>: Equatable, Identifiable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">init</span>(name: String) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">self</span>.name = name
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> id = UUID()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> name: String
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> obj1: Student = .<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> obj2: Student = .<span style="color:#66d9ef">init</span>(name: <span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">Equatable</span> <span style="color:#66d9ef">where</span> <span style="color:#66d9ef">Self</span>: Identifiable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> == (lhs: <span style="color:#66d9ef">Self</span>, rhs: <span style="color:#66d9ef">Self</span>) -&gt; Bool {
</span></span><span style="display:flex;"><span>        lhs.id == rhs.id
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(obj1 == obj2) <span style="color:#75715e">// return false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//extension Student {</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    static func == (lhs: Student, rhs: Student) -&gt; Bool {</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//        lhs.name == rhs.name</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    }</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//print(obj1 == obj2) // return true</span>
</span></span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>在樹莓派4上執行Swift</title>
            <link>/posts/2024-01-04-swift-on-rpi/</link>
            <pubDate>Thu, 04 Jan 2024 13:47:08 +0800</pubDate>
            
            <guid>/posts/2024-01-04-swift-on-rpi/</guid>
            <description>&lt;p&gt;之前剛買到樹莓派的時候就有在想，樹莓派上能不能執行Swift&lt;/p&gt;
&lt;p&gt;但是之前 Swift 要在 arm 架構上執行需要用其他人編譯的一個 Swift-arm 版本，&lt;/p&gt;
&lt;p&gt;總覺得沒那麼優雅就放棄了這個想法。&lt;/p&gt;
&lt;p&gt;直到最近閒來無事，想說樹莓派上的一些專案好像很久沒動了，就久違的來研究一下有沒有新的東西可以玩。&lt;/p&gt;
&lt;p&gt;這邊就不廢話了直接上腳本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;set -e
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# check if .az directory exists&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/.swift&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Swift is already installed&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    exit &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wget https://download.swift.org/swift-5.9.2-release/ubuntu2004-aarch64/swift-5.9.2-RELEASE/swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unzip swift-5.9.2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tar xzf swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Rename swift-5.9.2 to swift-5.9.2&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mv swift-5.9.2-RELEASE-ubuntu20.04-aarch64 swift-5.9.2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Move swift-5.9.2 to .swift&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mv swift-5.9.2 &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/.swift/&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Remove zip file&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rm swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Add swift to path&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export PATH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$PATH:$HOME/.swift/swift-5.9.2/usr/bin
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;把內容複製到樹莓派中，並且執行腳本&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>之前剛買到樹莓派的時候就有在想，樹莓派上能不能執行Swift</p>
<p>但是之前 Swift 要在 arm 架構上執行需要用其他人編譯的一個 Swift-arm 版本，</p>
<p>總覺得沒那麼優雅就放棄了這個想法。</p>
<p>直到最近閒來無事，想說樹莓派上的一些專案好像很久沒動了，就久違的來研究一下有沒有新的東西可以玩。</p>
<p>這邊就不廢話了直接上腳本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>set -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># check if .az directory exists</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -d <span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/.swift&#34;</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    echo <span style="color:#e6db74">&#34;Swift is already installed&#34;</span>
</span></span><span style="display:flex;"><span>    exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>wget https://download.swift.org/swift-5.9.2-release/ubuntu2004-aarch64/swift-5.9.2-RELEASE/swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Unzip swift-5.9.2&#34;</span>
</span></span><span style="display:flex;"><span>tar xzf swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Rename swift-5.9.2 to swift-5.9.2&#34;</span>
</span></span><span style="display:flex;"><span>mv swift-5.9.2-RELEASE-ubuntu20.04-aarch64 swift-5.9.2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Move swift-5.9.2 to .swift&#34;</span>
</span></span><span style="display:flex;"><span>mv swift-5.9.2 <span style="color:#e6db74">&#34;</span>$HOME<span style="color:#e6db74">/.swift/&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Remove zip file&#34;</span>
</span></span><span style="display:flex;"><span>rm swift-5.9.2-RELEASE-ubuntu20.04-aarch64.tar.gz
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Add swift to path&#34;</span>
</span></span><span style="display:flex;"><span>export PATH<span style="color:#f92672">=</span>$PATH:$HOME/.swift/swift-5.9.2/usr/bin
</span></span></code></pre></div><p>把內容複製到樹莓派中，並且執行腳本</p>
<p>就會下載 Swift-5.9 版本到 <code>~/.swift/</code> 這個資料夾中
並且將路徑加入到 <code>$PATH</code> 中</p>
<p>這個腳本並不是特別好，這邊只是簡單判定了有沒有安裝過、能跑起來。</p>
<p>跑起來會不會有bug什麼的還沒進行驗證。</p>
<p>後續有什麼有趣的 Swift 專案能在 Linux 上執行的話，再寫下一篇吧。</p>
]]></content>
        </item>
        
        <item>
            <title>iOS的OTA發布</title>
            <link>/posts/2022-06-20-ios-ota/</link>
            <pubDate>Mon, 20 Jun 2022 14:34:32 +0800</pubDate>
            
            <guid>/posts/2022-06-20-ios-ota/</guid>
            <description>&lt;p&gt;常見的iOS發布不外乎為&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;App Store上架&lt;/li&gt;
&lt;li&gt;Vpp Store上架（大量授權）&lt;/li&gt;
&lt;li&gt;TestFlight&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這三種方式都必須要通過審核（至少在寫文章的時候是這樣）&lt;/p&gt;
&lt;p&gt;那麼，如果只是發布給公司內部的員工使用。&lt;/p&gt;
&lt;p&gt;例如：給測試人員使用，或是給業務等前線單位試用的時候，也要經過審核的話就非常耗費時間。&lt;/p&gt;
&lt;p&gt;所以這邊就説說另外一種方式，可以不用通過Apple審核也可以進行發布的方式：&lt;code&gt;Ad Hoc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用Ad Hoc有一個前提，那就是目標手機必須要在開發者帳號下登記過。&lt;/p&gt;
&lt;p&gt;所以要先檢查&lt;code&gt;provisioning profile&lt;/code&gt;中有沒有手機的UDID。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2024註：&lt;/p&gt;
&lt;p&gt;這邊建議手機可以在註冊的時候把UUID跟機型、使用者之類的做個表管理一下&lt;/p&gt;
&lt;p&gt;透過解析 ipa 中的 &lt;code&gt;embbed provision profile&lt;/code&gt; 就能比較輕鬆的找出這個 ipa 有哪些人可以安裝&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;ad-hoc&#34;&gt;Ad Hoc&lt;/h2&gt;
&lt;p&gt;具體發布大概有以下步驟&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;li&gt;輸出 ipa&lt;/li&gt;
&lt;li&gt;準備 manifest.plist&lt;/li&gt;
&lt;li&gt;準備一個可以存取的網路空間(https)&lt;/li&gt;
&lt;li&gt;準備一個網頁或是QRCode&lt;/li&gt;
&lt;li&gt;執行下載&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述所有步驟裡面，最麻煩的大概就是一定要走https協定這件事。
所以這部分我覺得分兩個情境來看。&lt;/p&gt;
&lt;p&gt;如果走的是內網下載，之前有試過用python架設https server，是可以用的。
&lt;a href=&#34;https://chwang12341.medium.com/coding%E8%B5%B7%E4%BE%86-python-%E4%B8%80%E8%A1%8C%E6%8C%87%E4%BB%A4%E5%B0%B1%E8%83%BD%E8%BC%95%E9%AC%86%E5%BB%BA%E7%AB%8B%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8-simplehttpserver%E5%A5%97%E4%BB%B6-http-server%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-34c30b81c26&#34;&gt;ref of http&lt;/a&gt;
&lt;a href=&#34;https://stackoverflow.com/questions/19705785/python-3-simple-https-server&#34;&gt;ref of https&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果走的是外網下載，但是沒有購買SSL憑證。
那也可以自己建立憑證讓目標手機下載，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2024註&lt;/p&gt;
&lt;p&gt;後來好像不行了，建議走 Dropbox 吧&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;先來説說如果不用腳本的話要怎麼做到這些事情。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode中選擇&lt;code&gt;Archive&lt;/code&gt;，打包的時候記得挑好對應的&lt;code&gt;Build Configuration&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Organizer&lt;/code&gt;中選擇&lt;code&gt;Distribute App&lt;/code&gt;，選&lt;code&gt;Ad Hoc&lt;/code&gt;，之後就是一路&lt;code&gt;next&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;OTA的選項可以勾也可以不勾，勾起來的話會自動幫你產生一個manifest而已。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;manifest&lt;/code&gt;中的路徑、bundle identifier等相關資訊修改完&lt;/li&gt;
&lt;li&gt;將&lt;code&gt;ipa&lt;/code&gt;, &lt;code&gt;manifest&lt;/code&gt; 上傳到網路空間&lt;/li&gt;
&lt;li&gt;從網頁或是QR Code中執行下載功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;整套流程能使用&lt;code&gt;Fastlane&lt;/code&gt;去處理，會方便很多。
這邊是把最基礎的手動版本寫出來。&lt;/p&gt;&lt;/blockquote&gt;</description>
            <content type="html"><![CDATA[<p>常見的iOS發布不外乎為</p>
<ol>
<li>App Store上架</li>
<li>Vpp Store上架（大量授權）</li>
<li>TestFlight</li>
</ol>
<p>這三種方式都必須要通過審核（至少在寫文章的時候是這樣）</p>
<p>那麼，如果只是發布給公司內部的員工使用。</p>
<p>例如：給測試人員使用，或是給業務等前線單位試用的時候，也要經過審核的話就非常耗費時間。</p>
<p>所以這邊就説說另外一種方式，可以不用通過Apple審核也可以進行發布的方式：<code>Ad Hoc</code></p>
<p>使用Ad Hoc有一個前提，那就是目標手機必須要在開發者帳號下登記過。</p>
<p>所以要先檢查<code>provisioning profile</code>中有沒有手機的UDID。</p>
<blockquote>
<p>2024註：</p>
<p>這邊建議手機可以在註冊的時候把UUID跟機型、使用者之類的做個表管理一下</p>
<p>透過解析 ipa 中的 <code>embbed provision profile</code> 就能比較輕鬆的找出這個 ipa 有哪些人可以安裝</p></blockquote>
<h2 id="ad-hoc">Ad Hoc</h2>
<p>具體發布大概有以下步驟</p>
<ol>
<li>打包</li>
<li>輸出 ipa</li>
<li>準備 manifest.plist</li>
<li>準備一個可以存取的網路空間(https)</li>
<li>準備一個網頁或是QRCode</li>
<li>執行下載</li>
</ol>
<p>上述所有步驟裡面，最麻煩的大概就是一定要走https協定這件事。
所以這部分我覺得分兩個情境來看。</p>
<p>如果走的是內網下載，之前有試過用python架設https server，是可以用的。
<a href="https://chwang12341.medium.com/coding%E8%B5%B7%E4%BE%86-python-%E4%B8%80%E8%A1%8C%E6%8C%87%E4%BB%A4%E5%B0%B1%E8%83%BD%E8%BC%95%E9%AC%86%E5%BB%BA%E7%AB%8B%E7%B6%B2%E9%A0%81%E4%BC%BA%E6%9C%8D%E5%99%A8-simplehttpserver%E5%A5%97%E4%BB%B6-http-server%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8-34c30b81c26">ref of http</a>
<a href="https://stackoverflow.com/questions/19705785/python-3-simple-https-server">ref of https</a></p>
<p>如果走的是外網下載，但是沒有購買SSL憑證。
那也可以自己建立憑證讓目標手機下載，</p>
<blockquote>
<p>2024註</p>
<p>後來好像不行了，建議走 Dropbox 吧</p></blockquote>
<p>先來説說如果不用腳本的話要怎麼做到這些事情。</p>
<ol>
<li>Xcode中選擇<code>Archive</code>，打包的時候記得挑好對應的<code>Build Configuration</code>。</li>
<li>在<code>Organizer</code>中選擇<code>Distribute App</code>，選<code>Ad Hoc</code>，之後就是一路<code>next</code>
<ol>
<li>OTA的選項可以勾也可以不勾，勾起來的話會自動幫你產生一個manifest而已。</li>
</ol>
</li>
<li>將<code>manifest</code>中的路徑、bundle identifier等相關資訊修改完</li>
<li>將<code>ipa</code>, <code>manifest</code> 上傳到網路空間</li>
<li>從網頁或是QR Code中執行下載功能。</li>
</ol>
<blockquote>
<p>整套流程能使用<code>Fastlane</code>去處理，會方便很多。
這邊是把最基礎的手動版本寫出來。</p></blockquote>
]]></content>
        </item>
        
        <item>
            <title>新公司應該要注意的開發觀念</title>
            <link>/posts/2022-06-19-%E6%96%B0%E5%85%AC%E5%8F%B8%E6%87%89%E8%A9%B2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%96%8B%E7%99%BC%E8%A7%80%E5%BF%B5/</link>
            <pubDate>Sun, 19 Jun 2022 17:41:32 +0800</pubDate>
            
            <guid>/posts/2022-06-19-%E6%96%B0%E5%85%AC%E5%8F%B8%E6%87%89%E8%A9%B2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%96%8B%E7%99%BC%E8%A7%80%E5%BF%B5/</guid>
            <description>&lt;p&gt;最近被之前的同事找回以前離職的公司去幫忙收拾各種前人留下來的爛攤子&lt;/p&gt;
&lt;p&gt;花了一段時間以後，突然有所體悟。&lt;/p&gt;
&lt;p&gt;在老闆、主管、工程師都是新手的情況下，&lt;/p&gt;
&lt;p&gt;&lt;del&gt;在一個公司是新創、員工是新手、老闆不懂技術狀況下&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;一起合作下去是有一定程度上的難處的。&lt;/p&gt;
&lt;p&gt;這邊想說也想說做個簡單的記錄，讓自己以後有些資料可以參考。
也希望這些資料可以對其他人產生幫助。&lt;/p&gt;
&lt;p&gt;不過這邊都是以工程師的角度出發，
對於一個資方要怎麼面對勞方我就沒輒了啊。&lt;/p&gt;
&lt;h2 id=&#34;關於產品&#34;&gt;關於產品&lt;/h2&gt;
&lt;p&gt;工程師基本也等於魔術師，基本上就是把想像中的產品具現化出來。
能夠透過一些包裝、手法讓使用者有完全不一樣的使用體驗。&lt;/p&gt;
&lt;p&gt;但工程師不是魔法師，並不能夠透過念咒來無中生有，跳過研發直接變出產品。
工程師也不會通靈，並不知道客戶、老闆到底想要什麼東西。&lt;/p&gt;
&lt;p&gt;所以在跟工程師討論產品開發的過程中，記得不要畫餅，那是慰留工程師的時候才要說的。&lt;/p&gt;
&lt;p&gt;直接講說希望產品具備什麼功能、想要長什麼樣子、要返回什麼樣的資料就好了。&lt;/p&gt;
&lt;p&gt;當然這邊也並不是說要細化到每一個細節，包含畫面什麼顏色，資料要有哪些屬性等等。
有些規劃還是要由工程師來完成的。&lt;/p&gt;
&lt;p&gt;舉個例子吧，這間公司的老闆常常說「要做一個某某產品」，但是具體的細節一概不知。
包含目標客群有哪些、需要用到哪些技術、預計什麼時候上市。&lt;/p&gt;
&lt;p&gt;這在大公司可以，但是在小公司不行。&lt;/p&gt;
&lt;p&gt;因為在大公司有其他的主管負責分析、研究、規劃等功能，有資源能夠投入，失敗了也並不會影響到公司的生計。&lt;/p&gt;
&lt;p&gt;小公司一旦賭錯，整個公司都會直接陪進去。&lt;/p&gt;
&lt;p&gt;至少，大方向要給出來。線上的還是離線的，賣點是硬體還是軟體，商用的還是民用的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;關於文件&#34;&gt;關於文件&lt;/h2&gt;
&lt;p&gt;所有產品、功能在具現化的過程都是不斷地溝通討論。
產品在具現化的過程中必須要留下一些資料。
基本的就是研究數據、使用情境、開發環境。&lt;/p&gt;
&lt;p&gt;這部分都統稱為「文件」&lt;/p&gt;
&lt;p&gt;文件的撰寫與程式碼的註解基本保持一個原則：
「不要告訴我What，告訴我Why。」&lt;/p&gt;
&lt;p&gt;舉個「沒用」的例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 設定背景顏色，如果someCondition為真為黑色，為假則是藍色&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;view.background = someCondition ? .black : .blue
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;這種註解，不寫會更好。因為程式碼就能看得出來。
程式碼看不出來的是：「為什麼是藍色跟黑色」。&lt;/p&gt;
&lt;p&gt;開發過程中留下的文件也一樣。&lt;/p&gt;
&lt;p&gt;寫下「&lt;strong&gt;為什麼這樣寫&lt;/strong&gt;」比起「&lt;strong&gt;這裡寫了什麼&lt;/strong&gt;」更為重要。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;開發文件一定要留。可以不用畫多專業的UML圖、做多精美的PPT、Word。
但至少這功能想表達什麼要寫個文件。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;關於程式碼&#34;&gt;關於程式碼&lt;/h2&gt;
&lt;p&gt;對於程式碼來說，一定要有一套&lt;code&gt;Coding Style&lt;/code&gt;的工具，而且共同開發同一個專案的工程師必須要認同這裡面的一些規則。&lt;/p&gt;
&lt;p&gt;至於Coding Style工具的選擇，基本上每套語言幾乎都會有屬於自己的lint工具以及官方的推薦的naming規則。&lt;/p&gt;
&lt;p&gt;套用style的時機，可以設計在IDE要build code的時候，或是版控commit之前。&lt;/p&gt;
&lt;p&gt;程式碼有幾個注意點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;註解掉的程式碼請直接刪除，請用版控保護你的程式碼，而不是靠註解掉的程式碼。&lt;/li&gt;
&lt;li&gt;IDE自動產生的註解記得拿掉，例如說前人有很多的&lt;code&gt;TODO: //Auto generate method stub&lt;/code&gt;留在那邊，不知道為什麼。&lt;/li&gt;
&lt;li&gt;不要留下`20220603 modified這樣子的程式碼在上面。除了告訴後面的人你不會用版控以外，並沒有任何幫助。&lt;/li&gt;
&lt;li&gt;變數命名不要命一些aa bb，也不要留一堆print(++++)之類的東西&lt;/li&gt;
&lt;li&gt;不要在程式碼裡面留下常數，全部都請拿去定義。
&lt;ul&gt;
&lt;li&gt;3.14請定義成pi&lt;/li&gt;
&lt;li&gt;errorCode請定義成有意義的名稱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;關於版本控制&#34;&gt;關於版本控制&lt;/h2&gt;
&lt;p&gt;版本控制，我現在的理解就是：「所有的記錄都可以被追蹤」&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>最近被之前的同事找回以前離職的公司去幫忙收拾各種前人留下來的爛攤子</p>
<p>花了一段時間以後，突然有所體悟。</p>
<p>在老闆、主管、工程師都是新手的情況下，</p>
<p><del>在一個公司是新創、員工是新手、老闆不懂技術狀況下</del></p>
<p>一起合作下去是有一定程度上的難處的。</p>
<p>這邊想說也想說做個簡單的記錄，讓自己以後有些資料可以參考。
也希望這些資料可以對其他人產生幫助。</p>
<p>不過這邊都是以工程師的角度出發，
對於一個資方要怎麼面對勞方我就沒輒了啊。</p>
<h2 id="關於產品">關於產品</h2>
<p>工程師基本也等於魔術師，基本上就是把想像中的產品具現化出來。
能夠透過一些包裝、手法讓使用者有完全不一樣的使用體驗。</p>
<p>但工程師不是魔法師，並不能夠透過念咒來無中生有，跳過研發直接變出產品。
工程師也不會通靈，並不知道客戶、老闆到底想要什麼東西。</p>
<p>所以在跟工程師討論產品開發的過程中，記得不要畫餅，那是慰留工程師的時候才要說的。</p>
<p>直接講說希望產品具備什麼功能、想要長什麼樣子、要返回什麼樣的資料就好了。</p>
<p>當然這邊也並不是說要細化到每一個細節，包含畫面什麼顏色，資料要有哪些屬性等等。
有些規劃還是要由工程師來完成的。</p>
<p>舉個例子吧，這間公司的老闆常常說「要做一個某某產品」，但是具體的細節一概不知。
包含目標客群有哪些、需要用到哪些技術、預計什麼時候上市。</p>
<p>這在大公司可以，但是在小公司不行。</p>
<p>因為在大公司有其他的主管負責分析、研究、規劃等功能，有資源能夠投入，失敗了也並不會影響到公司的生計。</p>
<p>小公司一旦賭錯，整個公司都會直接陪進去。</p>
<p>至少，大方向要給出來。線上的還是離線的，賣點是硬體還是軟體，商用的還是民用的。</p>
<hr>
<h2 id="關於文件">關於文件</h2>
<p>所有產品、功能在具現化的過程都是不斷地溝通討論。
產品在具現化的過程中必須要留下一些資料。
基本的就是研究數據、使用情境、開發環境。</p>
<p>這部分都統稱為「文件」</p>
<p>文件的撰寫與程式碼的註解基本保持一個原則：
「不要告訴我What，告訴我Why。」</p>
<p>舉個「沒用」的例子</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">// 設定背景顏色，如果someCondition為真為黑色，為假則是藍色</span>
</span></span><span style="display:flex;"><span>view.background = someCondition ? .black : .blue
</span></span></code></pre></div><p>這種註解，不寫會更好。因為程式碼就能看得出來。
程式碼看不出來的是：「為什麼是藍色跟黑色」。</p>
<p>開發過程中留下的文件也一樣。</p>
<p>寫下「<strong>為什麼這樣寫</strong>」比起「<strong>這裡寫了什麼</strong>」更為重要。</p>
<blockquote>
<p>開發文件一定要留。可以不用畫多專業的UML圖、做多精美的PPT、Word。
但至少這功能想表達什麼要寫個文件。</p></blockquote>
<h2 id="關於程式碼">關於程式碼</h2>
<p>對於程式碼來說，一定要有一套<code>Coding Style</code>的工具，而且共同開發同一個專案的工程師必須要認同這裡面的一些規則。</p>
<p>至於Coding Style工具的選擇，基本上每套語言幾乎都會有屬於自己的lint工具以及官方的推薦的naming規則。</p>
<p>套用style的時機，可以設計在IDE要build code的時候，或是版控commit之前。</p>
<p>程式碼有幾個注意點：</p>
<ul>
<li>註解掉的程式碼請直接刪除，請用版控保護你的程式碼，而不是靠註解掉的程式碼。</li>
<li>IDE自動產生的註解記得拿掉，例如說前人有很多的<code>TODO: //Auto generate method stub</code>留在那邊，不知道為什麼。</li>
<li>不要留下`20220603 modified這樣子的程式碼在上面。除了告訴後面的人你不會用版控以外，並沒有任何幫助。</li>
<li>變數命名不要命一些aa bb，也不要留一堆print(++++)之類的東西</li>
<li>不要在程式碼裡面留下常數，全部都請拿去定義。
<ul>
<li>3.14請定義成pi</li>
<li>errorCode請定義成有意義的名稱</li>
</ul>
</li>
</ul>
<h2 id="關於版本控制">關於版本控制</h2>
<p>版本控制，我現在的理解就是：「所有的記錄都可以被追蹤」</p>
<p>這個概念必須要擴張到所有的產品、文件、記錄上。</p>
<p>版本控制，重要的是控制，而並非版本。</p>
<p>這邊說的版控並不是「放到版控系統」這麼簡單的事情。</p>
<p>而是應該具有<strong>透過現行的資訊，判斷出當前使用的版本</strong>的能力。</p>
<p>例如：</p>
<ul>
<li>測試<code>production code</code>中的某個bug，應該從主幹上取得最新的版本來進行測試。</li>
<li>要測試<code>release code</code>相關功能，應該從對應的分支取得最新版本來測試。</li>
<li>客戶反映了問題，應該要能透過客戶的版本號來檢查問題是否被處理過。</li>
</ul>
<p>版本控制有幾個要點：</p>
<ul>
<li>沒有用的程式（功能、分支、文件、資料夾、etc.）就不要留，但是刪除的節點記得留下說明。</li>
<li>上版的程式碼一定要有tag</li>
<li>不要取自己的名字當成分支名稱，毫無意義。</li>
<li>git flow要就好好做，不要污染develop。占著茅坑不拉屎。</li>
</ul>
<blockquote>
<p>韌體、前端、移動端、後端、資料庫schema一定要有對應，
而對應只能靠版本號碼，版本號碼只能靠版控或文件。</p></blockquote>
<p>後面想到再寫吧。</p>
<p>一樣舉個例子：</p>
<p>這家公司的<strong>所有，對，是所有</strong>。所有的東西都沒有版控。
但是這公司的版控並不具備相關的能力，或者說，工程師並沒有相對應的概念。</p>
<p>上線的Server程式可能在develop分支、某個feature分支、兩三個版本前的主幹節點都有可能；開發中的硬體可能具備某些功能，也可能不具備，可能修了某些問題，也可能沒修復。<del>族繁不及備載</del></p>
<h2 id="其他一些觀察到的狀況">其他一些觀察到的狀況</h2>
<ul>
<li>
<p>資料庫的使用者、帳號、密碼請設計規範一點，不要寫一堆用戶與資料卻都沒有用到。</p>
</li>
<li>
<p>對於不熟悉的東西不要亂改，去隨便設定防火牆或是更換預設IP, Port, etc.的設定。</p>
</li>
</ul>
<blockquote>
<p>如果為了安全性要進行修改，就把整套的功能都研究完再來處理。</p></blockquote>
<p>情境：</p>
<ul>
<li>遇到電信公司改IP，結果無法登入遠端機器。最後發現不只在管理區有擋，還在遠端機器內部寫死允許連線的IP。而且沒有留下文件</li>
<li>Jenkins的自動建制，因為Gitlab的port改過了，但是沒有去修改其他服務的對應port，所以CD自動壞掉。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Kobo Nickel Menu的用法</title>
            <link>/posts/2021-11-11-kobo-nickel-menu%E7%9A%84%E7%94%A8%E6%B3%95/</link>
            <pubDate>Thu, 11 Nov 2021 16:07:08 +0800</pubDate>
            
            <guid>/posts/2021-11-11-kobo-nickel-menu%E7%9A%84%E7%94%A8%E6%B3%95/</guid>
            <description>&lt;p&gt;如果要用kobo來看txt或是從calibre導入書籍有諸多不便，&lt;/p&gt;
&lt;p&gt;有聽說其他閱讀軟體可以抓但是有點懶得弄。&lt;/p&gt;
&lt;p&gt;後來看到大神的blog，有統整了怎麼安裝第三方閱讀器，就順便抓了一下。&lt;/p&gt;
&lt;p&gt;Koreader功能是真的多，但是相對的電力也是噴很快。不過書本的啟動速度還是比官方慢了一點。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是傳資料還是一個痛點。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;經歷各種不方便，後來無意中發現已經有大神寫好一個工具方便使用，那就是&lt;code&gt;Nickel Menu&lt;/code&gt;
這就是本篇的重點。&lt;/p&gt;
&lt;p&gt;基本上先參考這個連結來安裝第三方閱讀器，具體要安裝哪一個就看個人需求。
&lt;a href=&#34;https://chiahsien.github.io/post/alternative-kobo-e-reader-koreader-and-plato/&#34;&gt;安裝第三方閱讀器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝完以後右下角會出現一個&lt;code&gt;Nickel Menu&lt;/code&gt;的功能選項，裡面的選項是可以自訂的。下面會說明&lt;/p&gt;
&lt;p&gt;流程概略是這樣：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安裝第三方閱讀器&lt;/li&gt;
&lt;li&gt;打開KOReader&lt;/li&gt;
&lt;li&gt;在KOReader中打開SSH Server&lt;/li&gt;
&lt;li&gt;連線進Kobo，進到&lt;code&gt;/mnt/onboard/.adds/nm&lt;/code&gt;資料夾&lt;/li&gt;
&lt;li&gt;建立一個檔案，檔名自訂，不要加上副檔名&lt;del&gt;不確定加了會怎麼樣，可以自行嘗試，概不負責啊&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;加入想要的命令&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整體操作大致流程是這樣，前三點就不說了，直接從第四點往下講&lt;/p&gt;
&lt;p&gt;進到&lt;code&gt;/mnt/onboard/.adds/nm&lt;/code&gt;這邊後，裡面基本上會有一個doc檔，
裡面就是文件說明。&lt;/p&gt;
&lt;p&gt;建議可以用&lt;code&gt;cp&lt;/code&gt;複製一份以後，直接用&lt;code&gt;vi&lt;/code&gt;或是&lt;code&gt;nano&lt;/code&gt;來編輯。
下面有很多的範例可供參考&lt;/p&gt;
&lt;p&gt;這邊列一些我覺得比較實用的&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Reboot
menu_item               :main :Reboot :power :reboot

# Refresh library
menu_item               :main :Import books       :nickel_misc        :rescan_books_full

# Force Wifi On/Off
menu_item               :main :Force Wi-Fi On (toggle)       :nickel_setting        :toggle:force_wifi

# Toggle Telnet
menu_item               :main :Telnet (toggle)    :cmd_output         :500:quiet :/usr/bin/pkill -f &amp;#34;^/usr/bin/tcpsvd -E 0.0.0.0 2023&amp;#34;
  chain_success:skip:5
    chain_failure                      :cmd_spawn          :quiet :/bin/mount -t devpts | /bin/grep -q /dev/pts || { /bin/mkdir -p /dev/pts &amp;amp;&amp;amp; /bin/mount -t devpts devpts /dev/pts; }
    chain_success                      :cmd_spawn          :quiet :exec /usr/bin/tcpsvd -E 0.0.0.0 2023 /usr/sbin/telnetd -i -l /bin/login
    chain_success                      :dbg_toast          :Started Telnet server on port 2023
    chain_failure                      :dbg_toast          :Error starting Telnet server on port 2023
    chain_always:skip:-1
  chain_success                        :dbg_toast          :Stopped Telnet server on port 2023

# Open FTP
menu_item               :main    :FTP                :cmd_spawn          :quiet:/usr/bin/pkill -f &amp;#34;^/usr/bin/tcpsvd -E 0.0.0.0 1021&amp;#34; || true &amp;amp;&amp;amp; exec /usr/bin/tcpsvd -E 0.0.0.0 1021 /usr/sbin/ftpd -w -t 30 /mnt/onboard
  chain_success                        :dbg_toast          :Started FTP server for KOBOeReader partition on port 1021.

# Show IP
menu_item               :main    :IP Address         :cmd_output         :500:/sbin/ifconfig | /usr/bin/awk &amp;#39;/inet addr/{print substr($2,6)}&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;mac端基本設定&#34;&gt;mac端基本設定&lt;/h2&gt;
&lt;p&gt;這邊是用macOS，但是基於安全性macOS已經移除了&lt;code&gt;telnet&lt;/code&gt;這個套件
所以要先安裝&lt;code&gt;telnet&lt;/code&gt;，這邊推薦用&lt;code&gt;inetutils&lt;/code&gt;，裡面就包含了&lt;code&gt;telnet, FTP&lt;/code&gt;等&lt;/p&gt;</description>
            <content type="html"><![CDATA[<p>如果要用kobo來看txt或是從calibre導入書籍有諸多不便，</p>
<p>有聽說其他閱讀軟體可以抓但是有點懶得弄。</p>
<p>後來看到大神的blog，有統整了怎麼安裝第三方閱讀器，就順便抓了一下。</p>
<p>Koreader功能是真的多，但是相對的電力也是噴很快。不過書本的啟動速度還是比官方慢了一點。</p>
<p><strong>但是傳資料還是一個痛點。</strong></p>
<p>經歷各種不方便，後來無意中發現已經有大神寫好一個工具方便使用，那就是<code>Nickel Menu</code>
這就是本篇的重點。</p>
<p>基本上先參考這個連結來安裝第三方閱讀器，具體要安裝哪一個就看個人需求。
<a href="https://chiahsien.github.io/post/alternative-kobo-e-reader-koreader-and-plato/">安裝第三方閱讀器</a></p>
<p>安裝完以後右下角會出現一個<code>Nickel Menu</code>的功能選項，裡面的選項是可以自訂的。下面會說明</p>
<p>流程概略是這樣：</p>
<ol>
<li>安裝第三方閱讀器</li>
<li>打開KOReader</li>
<li>在KOReader中打開SSH Server</li>
<li>連線進Kobo，進到<code>/mnt/onboard/.adds/nm</code>資料夾</li>
<li>建立一個檔案，檔名自訂，不要加上副檔名<del>不確定加了會怎麼樣，可以自行嘗試，概不負責啊</del></li>
<li>加入想要的命令</li>
</ol>
<p>整體操作大致流程是這樣，前三點就不說了，直接從第四點往下講</p>
<p>進到<code>/mnt/onboard/.adds/nm</code>這邊後，裡面基本上會有一個doc檔，
裡面就是文件說明。</p>
<p>建議可以用<code>cp</code>複製一份以後，直接用<code>vi</code>或是<code>nano</code>來編輯。
下面有很多的範例可供參考</p>
<p>這邊列一些我覺得比較實用的</p>
<pre tabindex="0"><code># Reboot
menu_item               :main :Reboot :power :reboot

# Refresh library
menu_item               :main :Import books       :nickel_misc        :rescan_books_full

# Force Wifi On/Off
menu_item               :main :Force Wi-Fi On (toggle)       :nickel_setting        :toggle:force_wifi

# Toggle Telnet
menu_item               :main :Telnet (toggle)    :cmd_output         :500:quiet :/usr/bin/pkill -f &#34;^/usr/bin/tcpsvd -E 0.0.0.0 2023&#34;
  chain_success:skip:5
    chain_failure                      :cmd_spawn          :quiet :/bin/mount -t devpts | /bin/grep -q /dev/pts || { /bin/mkdir -p /dev/pts &amp;&amp; /bin/mount -t devpts devpts /dev/pts; }
    chain_success                      :cmd_spawn          :quiet :exec /usr/bin/tcpsvd -E 0.0.0.0 2023 /usr/sbin/telnetd -i -l /bin/login
    chain_success                      :dbg_toast          :Started Telnet server on port 2023
    chain_failure                      :dbg_toast          :Error starting Telnet server on port 2023
    chain_always:skip:-1
  chain_success                        :dbg_toast          :Stopped Telnet server on port 2023

# Open FTP
menu_item               :main    :FTP                :cmd_spawn          :quiet:/usr/bin/pkill -f &#34;^/usr/bin/tcpsvd -E 0.0.0.0 1021&#34; || true &amp;&amp; exec /usr/bin/tcpsvd -E 0.0.0.0 1021 /usr/sbin/ftpd -w -t 30 /mnt/onboard
  chain_success                        :dbg_toast          :Started FTP server for KOBOeReader partition on port 1021.

# Show IP
menu_item               :main    :IP Address         :cmd_output         :500:/sbin/ifconfig | /usr/bin/awk &#39;/inet addr/{print substr($2,6)}&#39;
</code></pre><h2 id="mac端基本設定">mac端基本設定</h2>
<p>這邊是用macOS，但是基於安全性macOS已經移除了<code>telnet</code>這個套件
所以要先安裝<code>telnet</code>，這邊推薦用<code>inetutils</code>，裡面就包含了<code>telnet, FTP</code>等</p>
<p>安裝語法：
<code>brew install inetutils</code></p>
<p>安裝完成後就可以用 <code>telnet kobo-reader-ip</code>連線進Kobo了
帳號是<code>root</code>，沒有密碼。
因為是<code>root</code>，各種操作請自行小心！</p>
<p><a href="https://pgaskin.net/NickelMenu/">Official site</a></p>
<p><a href="https://tylpk.blogspot.com/2021/07/nickelmenu.html">參考連結</a></p>
]]></content>
        </item>
        
        <item>
            <title>Git常用命令筆記</title>
            <link>/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/</link>
            <pubDate>Wed, 10 Nov 2021 23:47:08 +0800</pubDate>
            
            <guid>/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/</guid>
            <description>Git常用命令筆記</description>
            <content type="html"><![CDATA[<ul>
<li><a href="/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/#%e5%9f%ba%e6%9c%ac%e5%91%bd%e4%bb%a4">基本命令</a>
<ul>
<li><a href="/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/#stash">stash</a></li>
<li><a href="/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/#clean">clean</a></li>
</ul>
</li>
<li><a href="/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/#%e6%87%89%e7%94%a8%e7%af%87">應用篇</a>
<ul>
<li><a href="/posts/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/#%e9%87%8d%e6%96%b0%e5%91%bd%e5%90%8d">重新命名</a></li>
</ul>
</li>
</ul>
<p>老實說，Git很好用，但是有很多突發狀況下，Git的命令常常會想不太起來或是忘記怎麼用。</p>
<p>這邊有印象就寫個筆記</p>
<h1 id="基本命令">基本命令</h1>
<h3 id="stash">stash</h3>
<p>如果今天突然有問題要修改，但是你現在的code又還不能commit
那麼就適合用<code>stash</code>來保存這些異動</p>
<p>基本命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 保存當前所有異動</span>
</span></span><span style="display:flex;"><span>git stash save
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 讀取stash i</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 請善用自動補完，i代表第幾個stash，不是真的命令</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 這兩個命令基本上是一樣的，所以寫在一起</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 差別在於pop取得異動後，會直接刪掉stash中的備份，而apply不會</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 所以如果你只是想「取出來看看」，建議用apply</span>
</span></span><span style="display:flex;"><span>git stash pop stash@<span style="color:#ae81ff">\{</span>i<span style="color:#ae81ff">\}</span>
</span></span><span style="display:flex;"><span>git stash apply stash@<span style="color:#ae81ff">\{</span>i<span style="color:#ae81ff">\}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 列出所有的stash</span>
</span></span><span style="display:flex;"><span>git stash list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 拋棄stash i</span>
</span></span><span style="display:flex;"><span>git stash drop stash@<span style="color:#ae81ff">\{</span>i<span style="color:#ae81ff">\}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 顯示stash i有哪些檔案有異動</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果要更精細的看異動內容，就加上 -p 這個變數</span>
</span></span><span style="display:flex;"><span>git stash show stash@<span style="color:#ae81ff">\{</span>i<span style="color:#ae81ff">\}</span>
</span></span></code></pre></div><p>常用命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 用來保存當前所有的異動，message為這個stash的說明，或著說註解。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 在 git stash list 的時候會看得到</span>
</span></span><span style="display:flex;"><span>git stash save -m <span style="color:#e6db74">&#39;message&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 互動式的stash，如果只要stash部分異動，那麼就可以用這個命令。</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 這會把有異動的檔案找出來，然後分片段詢問要不要保留</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 基本上的git add --patch 的用法一樣</span>
</span></span><span style="display:flex;"><span>git stash save --patch 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 當你只想保留特定檔案，但是不想用add --patch的話</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 可以直接用 -- 檔案路徑</span>
</span></span><span style="display:flex;"><span>git stash -- project/module/file.xxx
</span></span></code></pre></div><h3 id="clean">clean</h3>
<p>針對那些沒有被版控的檔案，如果老是要一個一個刪就會很煩躁</p>
<p>這個沒啥好筆記的，直接把可用變數列出來好了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--dry-run      -n  -- only show what would and what would not be removed
</span></span><span style="display:flex;"><span>--exclude      -e  -- skip files matching specified pattern
</span></span><span style="display:flex;"><span>--force        -f  -- required when clean.requireForce is true <span style="color:#f92672">(</span>default<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>--interactive  -i  -- show what would be <span style="color:#66d9ef">done</span> and clean files interactively
</span></span><span style="display:flex;"><span>--quiet        -q  -- don<span style="color:#960050;background-color:#1e0010">&#39;</span>t print names of files removed
</span></span><span style="display:flex;"><span>-X                 -- remove only ignored files
</span></span><span style="display:flex;"><span>-d                 -- also remove untracked directories
</span></span><span style="display:flex;"><span>-x                 -- also remove ignored files
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 強制刪除所有untracked files，而且連資料夾也會刪除</span>
</span></span><span style="display:flex;"><span>git clean -f -d
</span></span></code></pre></div><hr>
<hr>
<h1 id="應用篇">應用篇</h1>
<hr>
<hr>
<h3 id="重新命名">重新命名</h3>
<pre tabindex="0"><code>// 重新命名分支
git branch -m &lt;oldname&gt; &lt;newname&gt;

// 重新命名當前分支
git branch -m &lt;newname&gt;
</code></pre><p><a href="https://stackoverflow.com/questions/6591213/how-do-i-rename-a-local-git-branch">reference</a></p>
]]></content>
        </item>
        
        <item>
            <title>EnterHealth Support</title>
            <link>/posts/apps/enterhealth/support/</link>
            <pubDate>Tue, 09 Nov 2021 19:18:33 +0800</pubDate>
            
            <guid>/posts/apps/enterhealth/support/</guid>
            <description>EnterHealth support</description>
            <content type="html"><![CDATA[<h1 id="enterhealth">EnterHealth</h1>
<p>EnterHealth 提供簡單易用的方式輸入健康資訊到Apple的健康之中。
讓健康資訊不再散落在各地。</p>
<p>以輕鬆記錄血壓資訊為主建立的App</p>
<p>因為家人有記錄血壓的需求，所以想幫他們建立一個容易閱讀、記錄的軟體。</p>
<p>相關的健康資訊都會保留在Apple提供的「健康」App中</p>
<p>・使用Apple的Health保存資訊，不再將健康資訊儲存在多個地方。</p>
<p>・提供保存「最近刪除的記錄」讓手滑刪除後還能救得回來。</p>
<p>提醒：
刪除的資訊只會保留在手機之中，並不會上傳到網路。
如果在「健康App」中刪除這些資訊，則不會被保留記錄，該檔案將會永久刪除。</p>
<ul>
<li>
<p>可以匯出JSON與CSV格式的檔案，可以提供給醫療人員幫忙分析。</p>
</li>
<li>
<p>提供通知來提醒自己量測血壓。</p>
</li>
</ul>
<p>如果需要任何支援或提供建議</p>
<p>歡迎<a href="insidehand@gmail.com">來信</a></p>
]]></content>
        </item>
        
        <item>
            <title>EnterHealth Terms</title>
            <link>/posts/apps/enterhealth/terms_and_privacy_policy/</link>
            <pubDate>Tue, 09 Nov 2021 19:18:33 +0800</pubDate>
            
            <guid>/posts/apps/enterhealth/terms_and_privacy_policy/</guid>
            <description>EnterHealth terms and privacy policy</description>
            <content type="html"><![CDATA[<h1 id="enterhealth">EnterHealth</h1>
<h2 id="使用條款">使用條款</h2>
<p>EnterHealth提供記錄血壓、心律等健康數據。</p>
<p>輸入的數據會儲存於Apple.Inc提供的健康 App之中。</p>
<p>刪除的數據會被保存在手機本地之中，
方便搶救誤刪的資料。</p>
<p>用戶可以隨時刪除這些保存的資料，這次的刪除則是永久性的。
刪除後則無法再次恢復這些資料。</p>
<h3 id="免責聲明">免責聲明</h3>
<ul>
<li>
<p>請用戶對於自己輸入的資料正確性負責。任何數據所衍生的問題，EnterHealth概不負責</p>
</li>
<li>
<p>因為資料不會上傳，所以請用戶妥善保存這些資訊。任何數據遺失衍生的問題，EnterHealth概不負責。</p>
</li>
</ul>
<hr>
<h2 id="隱私權政策">隱私權政策</h2>
<p><strong>EnterHealth不會使用任何用戶資料。</strong></p>
<p>所有輸入的資料都會儲存到Apple.Inc的Health中，</p>
<p>你可以在任何時間透過隱私權設定拒絕EnterHealth存取Health中的資料。</p>
<p>EnterHealth會保留「最近刪除的記錄」，用戶可以隨時永久性的刪除這些資訊。</p>
]]></content>
        </item>
        
        <item>
            <title>LooPlayer privacy term</title>
            <link>/posts/apps/looplayer/privacy_policy/</link>
            <pubDate>Tue, 09 Nov 2021 19:18:33 +0800</pubDate>
            
            <guid>/posts/apps/looplayer/privacy_policy/</guid>
            <description>LooPlayer support</description>
            <content type="html"><![CDATA[<h1 id="looplayer">LooPlayer</h1>
<h2 id="隱私權政策">隱私權政策</h2>
<p><strong>LooPlayer</strong> 是一個簡單的循環播放筆記軟體</p>
<p>由<strong>LooPlayer</strong>所產生的資料會被儲存在app本地或是iCloud之中。</p>
<p>無論是儲存在哪裡，這些資料都只會被你所使用。</p>
<p><strong>LooPlayer</strong>並不會搜集或使用你的任何資訊。</p>
]]></content>
        </item>
        
        <item>
            <title>Requestflow Support</title>
            <link>/posts/apps/requestflow/privacy_policy/</link>
            <pubDate>Tue, 09 Nov 2021 19:18:33 +0800</pubDate>
            
            <guid>/posts/apps/requestflow/privacy_policy/</guid>
            <description>Requestflow support</description>
            <content type="html"><![CDATA[<h1 id="requestflow">Requestflow</h1>
<h2 id="隱私權政策">隱私權政策</h2>
<p><strong>Requestflow</strong> 是一個純粹的網路測試工具</p>
<p>由<strong>Requestflow</strong>所產生的資料會被儲存在app本地或是iCloud之中。</p>
<p>無論是儲存在哪裡，這些資料都只會被你所使用。</p>
<p><strong>Requestflow</strong>並不會搜集或使用你的任何資訊。</p>
<p>由於許多網站的設計並不相同，送出的資訊可能會造成資料缺失，請小心的處理你要送出的資訊。任何使用本軟體所造成的損害，Requestflow概不負責。</p>
]]></content>
        </item>
        
        <item>
            <title>如何快速找到Simulator的Document位置</title>
            <link>/posts/2021-11-09-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0simulator%E7%9A%84document%E4%BD%8D%E7%BD%AE/</link>
            <pubDate>Tue, 09 Nov 2021 19:18:33 +0800</pubDate>
            
            <guid>/posts/2021-11-09-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0simulator%E7%9A%84document%E4%BD%8D%E7%BD%AE/</guid>
            <description>&lt;h1 id=&#34;如何快速找到simulator的document位置&#34;&gt;如何快速找到Simulator的Document位置&lt;/h1&gt;
</description>
            <content type="html"><![CDATA[<p>如題，使用模擬器開發的時候，如果想要快速的從Finder或Terminal中直接存取App的資料夾的話
最快的方法就是用<code>lldb</code>的命令</p>
<p><code>po NSHomeDirectory()</code></p>
<p>只要在模擬器使用期間直接暫停<code>（cmd + ctrl + y）</code>，讓<code>lldb</code>可以下命令</p>
<p>就可以直接輸入上面的命令，對應的位置就會顯示出來了</p>
<p><a href="https://stackoverflow.com/questions/1108076/where-does-the-iphone-simulator-store-its-data">reference</a></p>
]]></content>
        </item>
        
        <item>
            <title>另外一種方式的依賴控制</title>
            <link>/posts/2021-10-11-%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A8%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B3%B4%E6%8E%A7%E5%88%B6/</link>
            <pubDate>Mon, 11 Oct 2021 17:41:32 +0800</pubDate>
            
            <guid>/posts/2021-10-11-%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A8%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B3%B4%E6%8E%A7%E5%88%B6/</guid>
            <description>&lt;h2 id=&#34;什麼是依賴為什麼要管理&#34;&gt;什麼是依賴，為什麼要管理？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;任何你不能控制的物件，都是隱藏的依賴&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;具體來說，如果程式完全不寫測試，那麼其實就不用考慮依賴的問題。&lt;/p&gt;
&lt;p&gt;要管理依賴的理由在於給測試一個介入的途徑。&lt;/p&gt;
&lt;p&gt;例如說有一個物件是用來追蹤聖誕老人，裡面判斷他有沒有上班。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SantaClausTracker&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isWorking&lt;/span&gt;() -&amp;gt; Bool {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; today = Date()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; month = Calendar.current.components(.month, today)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; day = Calendar.current.components(.day, today)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; month == &lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; day == &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;顯然，要這個方法回傳&lt;code&gt;true&lt;/code&gt;的話，就只能在聖誕節當天進行測試。
其他日子回傳都是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這個方法裡面有兩個依賴，一個是&lt;code&gt;Date()&lt;/code&gt;，另一個則是&lt;code&gt;Calendar.current&lt;/code&gt;。
如果想要把這些依賴變得可控，那麼就是要透過外部傳入。也就是依賴注入（dependency injection）&lt;/p&gt;
&lt;p&gt;傳統的方法有三：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建構子注入&lt;/li&gt;
&lt;li&gt;屬性注入&lt;/li&gt;
&lt;li&gt;方法參數注入&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;名稱應該足以描述相對應的行為，就不多贅述了。&lt;/p&gt;
&lt;p&gt;換言之，在程式碼中，只要是&lt;code&gt;使用&lt;/code&gt;的物件，都要記得可以替換。
舉個例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;(X
func somefunction() {
    Date() 
}

(O
func somefunction(date: Date) {
    date 
}

(X
func somefunction() {
    URLSession.share
}

(🔺
func somefunction(session: URLSession) {
    session
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那麼，顯然會出現的問題就是「&lt;strong&gt;依賴要怎麼來&lt;/strong&gt;」&lt;/p&gt;</description>
            <content type="html"><![CDATA[<h2 id="什麼是依賴為什麼要管理">什麼是依賴，為什麼要管理？</h2>
<blockquote>
<p>任何你不能控制的物件，都是隱藏的依賴</p></blockquote>
<p>具體來說，如果程式完全不寫測試，那麼其實就不用考慮依賴的問題。</p>
<p>要管理依賴的理由在於給測試一個介入的途徑。</p>
<p>例如說有一個物件是用來追蹤聖誕老人，裡面判斷他有沒有上班。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SantaClausTracker</span> {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isWorking</span>() -&gt; Bool {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> today = Date()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> month = Calendar.current.components(.month, today)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> day = Calendar.current.components(.day, today)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> month == <span style="color:#ae81ff">12</span> <span style="color:#f92672">&amp;&amp;</span> day == <span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>顯然，要這個方法回傳<code>true</code>的話，就只能在聖誕節當天進行測試。
其他日子回傳都是<code>false</code>。</p>
<p>這個方法裡面有兩個依賴，一個是<code>Date()</code>，另一個則是<code>Calendar.current</code>。
如果想要把這些依賴變得可控，那麼就是要透過外部傳入。也就是依賴注入（dependency injection）</p>
<p>傳統的方法有三：</p>
<ol>
<li>建構子注入</li>
<li>屬性注入</li>
<li>方法參數注入</li>
</ol>
<p>名稱應該足以描述相對應的行為，就不多贅述了。</p>
<p>換言之，在程式碼中，只要是<code>使用</code>的物件，都要記得可以替換。
舉個例子</p>
<pre tabindex="0"><code>(X
func somefunction() {
    Date() 
}

(O
func somefunction(date: Date) {
    date 
}

(X
func somefunction() {
    URLSession.share
}

(🔺
func somefunction(session: URLSession) {
    session
}
</code></pre><p>那麼，顯然會出現的問題就是「<strong>依賴要怎麼來</strong>」</p>
<p>例如說一個App畫面堆疊是這樣</p>
<p><del>先不討論畫面層級太深的問題</del>這可以看一個精彩的影片「<a href="https://www.ted.com/talks/david_pogue_simplicity_sells">至簡暢銷</a>」</p>
<pre class="mermaid">graph LR
View1 --> View2 --> View3 --> View4
</pre>
<p>今天View4有呼叫API的需要，View2 , 3沒有。
要present View4只能夠過View3（MVC）或是View3的Coordinator（MVVM C）
勢必View2, 3都必須要攜帶一個用不到的物件。</p>
<p>當今天底層越多，依賴拆分的越細，就中間的層級就容易要傳遞一些用不到的物件。</p>
<p><strong>久了就不容易維護，不容易維護就等於隱藏的Bug</strong></p>
<p>以前寫過類似的程式碼，中間傳遞的參數多了，就需要使用DTO來打包，多一層又顯得冗余。</p>
<p>這時候就看到一個突破天際的想法<a href="https://vimeo.com/291588126">How to control the World</a></p>
<p><strong>強烈建議看影片</strong></p>
<p><strong>強烈建議看影片</strong></p>
<p><strong>強烈建議看影片</strong></p>
<p>先來看看實作，把需要的依賴宣告在一個struct中</p>
<pre tabindex="0"><code>struct World {
  var date = { Date() }
}
</code></pre><blockquote>
<p>這邊要注意的是並不是透過「方法」來取值，例如說
<code>func getDate() -&gt; Date { ... }</code>
因為方法的實作是不可異動的，本質上還是依賴，只是把依賴集中到一個地方管理。</p>
<p>也不是直接是一個Date屬性
因為當你存取Current.date時，每次取的都是不一樣的值
如果想要每次都取得同一個時間的話，就做不到這個需求</p>
<p>當然這邊也可以把這個<code>struct</code>改寫成<code>protocol</code>，然後實作不同的物件來提供不同的測試需要，不過那就是另外一回事了。</p></blockquote>
<p>說回正題，當你宣告了這樣的<code>struct</code>，你還需要一個<strong>全域</strong>的<strong>變數</strong></p>
<pre tabindex="0"><code>var Current = World()
</code></pre><blockquote>
<p>這是一個<code>Singleton</code>！<del>皮諾可，這個直接電死</del></p></blockquote>
<p>別急，這時候這個設計神的地方來了。</p>
<p>用上面的範例來實作的話就會變這樣</p>
<pre tabindex="0"><code>struct SantaClusTracker {
  
  func isWorking() -&gt; Bool {
    //暫時先改一個，baby step
    let today = Current.date()
    let month = Calendar.current.components(.month, today)
    let day = Calendar.current.components(.day, today)
    return month == 12 &amp;&amp; day == 25
  }

}
</code></pre><p>因為<code>Current</code>是一個<code>var</code>，所以裡面的屬性是可以異動的。
因為<code>date</code>是一個<code>回傳Date的function</code>，所以實作內容也是可以異動的</p>
<p>今天需要測試的時候，可以直接對<code>Current</code>設值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test_Date_Is_Christmas_SantaClausTracker_isWorking_should_return_true</span>() <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 3A原則，具體可以參考91的文章或是聽他的課！獲益良多 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Arrange</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> target = SantaClausTracker()
</span></span><span style="display:flex;"><span>  Current.date = { 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> formatter = DateFormatter()
</span></span><span style="display:flex;"><span>     formatter.dateFormat = <span style="color:#e6db74">&#34;yyyy/MM/dd&#34;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> formatter.date(string: <span style="color:#e6db74">&#34;2021/12/25&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Action</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> actual = target.isWorking()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Assert</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> expect = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  XCTAssertEqual(actual, expect)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此，就算是在其他日子，也能檢查在聖誕節的時候是不是會回傳<code>true</code></p>
<p>這邊先討論幾個問題</p>
<ol>
<li>Singleton不是不好，為什麼要用？</li>
<li>為什麼不用介面隔開？</li>
<li>全域變數很危險，不應該用不是嗎？</li>
</ol>
<h3 id="singleton不是不好為什麼要用">Singleton不是不好，為什麼要用？</h3>
<p>Singleton並不是不好，不好的話Apple還到處放不是很奇怪？</p>
<p><code>URLSession.shared</code></p>
<p><code>UserDefaults.standard</code></p>
<p><code>FileManager.default</code></p>
<p>Singleton的問題在於它是一個實體型別，無法被抽象化。也就是無法在測試中被替換。當你今天在程式碼中放了<code>URLSession.shared</code>以後，就註定了他一定會去走真實的網路（用intercepter擋掉另當別論），而沒辦法用<code>MockURLSession</code>來進行替換</p>
<h3 id="為什麼不用介面隔開">為什麼不用介面隔開？</h3>
<p>在看這個影片之前，我也是用<code>protocol</code>來進行區隔，這也有一個大神的文章可以參考<a href="https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k">歡迎來到真實世界</a></p>
<p>先來談談如果用介面隔開URLSession，要做多少動作？</p>
<ol>
<li>製作一個介面<code>URLSessionProtocol</code>，方法簽章要跟URLSession中要呼叫的方法一致</li>
<li>讓URLSession擴充<code>URLSessionProtocol</code>，因為方法已經存在，所以不用另外實作。</li>
<li>製作一個測試在用的物件<code>MockURLSession</code>，實作介面<code>URLSessionProtocol</code>，裡面不涉及網路存取，直接回傳值。</li>
<li>將原本程式碼呼叫<code>URLSession.shared</code>的地方全部抽換掉</li>
<li>在測試中將<code>MockURLSession</code>注入到測試目標中</li>
</ol>
<p>首先，這個做法對程式碼改動幅度比較大，當早期沒做，後面要抽換的時候改動幅度就會很大，也是存在風險。</p>
<p>其次，如果介面裡面的方法開始變多以後，一個新的Mock物件實作起來不容易。</p>
<blockquote>
<p>例如說一個資料庫存取介面，有四個方法CRUD</p>
<p>那麼建立一個新的Mock物件就要實作四個方法。</p>
<p>而一個正常的介面方法都不止四個</p></blockquote>
<h3 id="全域變數很危險不應該用不是嗎">全域變數很危險，不應該用不是嗎？</h3>
<p>全域變數的危險之處在於「<strong>你不知道什麼時候被改動</strong>」</p>
<p>誠然，設定為變數是存在風險的，但是不應該把<code>Current</code>當成是一個傳遞、暫存參數的地方。而是一個依賴保管區（Production時）、依賴注入區（Develop時）</p>
<p>說回這個方法</p>
<p>如果今天要測試使用者登入「<strong>成功</strong>」與「<strong>失敗</strong>」的情境</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserAPIClient</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;API Path&#34;</span>)<span style="color:#f92672">!</span> <span style="color:#75715e">// &lt;-- 這裡一定run time error</span>
</span></span><span style="display:flex;"><span>        URLSession.shared.dataTask(with: url) { data, <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            complectionHandler(data == <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                UserAPIClient().login(account: <span style="color:#e6db74">&#34;account&#34;</span>, password: <span style="color:#e6db74">&#34;password&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>UserAPIClient</code>有一個一定會在run time炸掉的地方，那就是<code>URL(string: &quot;API Path&quot;)!</code></p>
<p>假想這是Server暫時不可用，或是網路斷線的情境吧。</p>
<p>那這種時候就不用測試了嗎？沒錯！<del>後台修好再叫我</del></p>
<p>當然不可能，所以這時候就需要脫離實際環境來測試功能是否正常。</p>
<p>用<code>protocol</code>的方式來進行脫鉤是這樣實作的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">//1. 定義協議</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">UserAPIClientProtocol</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//2. 讓原本的物件擴充這個協議</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">UserAPIClient</span>: UserAPIClientProtocol { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//3. 建立測試物件，因為測試情境有「成功」「失敗」，所以回傳值用建構注入</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MockUserAPIClient</span>: UserAPIClientProtocol {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> loginResult: Bool
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void ) {
</span></span><span style="display:flex;"><span>      complectionHandler(loginResult)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//4. 將原本的型別用介面抽換（呼叫的時候要注入）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> userAPIClient: UserAPIClientProtocol
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                userAPIClient.login(account: <span style="color:#e6db74">&#34;acc&#34;</span>, password: <span style="color:#e6db74">&#34;pass&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//5. 修改呼叫端</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView_Previews</span>: PreviewProvider {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> previews: some View {
</span></span><span style="display:flex;"><span>        ContentView(userAPIClient: MockUserAPIClient(loginResult: <span style="color:#66d9ef">true</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果用World來控制的話，是這個樣子的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserAPI</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> login = UserAPIClient().login(account:password:complectionHandler:)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">World</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> userAPI = UserAPI()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> Current = World()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                Current.userAPI.login(<span style="color:#e6db74">&#34;account&#34;</span>, <span style="color:#e6db74">&#34;password&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//修改呼叫端</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView_Previews</span>: PreviewProvider {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> previews: some View {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//正常不會在這邊修改，這邊只是懶得把資料切乾淨所以放著舉例一下</span>
</span></span><span style="display:flex;"><span>        Current.userAPI.login = { <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">_</span>, callback <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            callback(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ContentView()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看起來有點差異，但是好像又差異不大？
當你再遇到這樣的需求時</p>
<pre class="mermaid">graph LR
View1 --> View2 --> View3 --> View4
</pre>
<p>View2, 3就不需要攜帶<code>UserAPIClient</code>跑來跑去了</p>
<p><strong>最重要的是</strong>
當你的測試情境需要不同的回傳值時，不再需要像上面的<code>MockUserAPIClient</code>一樣透過各種注入，考慮各種測試情境要呼叫方法時的通用性，而是可以直接針對特定方法改寫方法實作內容。</p>
<h2 id="參考文章">參考文章：</h2>
<p><a href="https://vimeo.com/291588126">https://vimeo.com/291588126</a></p>
<p><a href="https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k">https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k</a></p>
]]></content>
        </item>
        
        <item>
            <title>關於GCD的一些筆記-1</title>
            <link>/posts/2020-06-29-gcd%E7%AD%86%E8%A8%98-01/</link>
            <pubDate>Mon, 29 Jun 2020 19:18:33 +0800</pubDate>
            
            <guid>/posts/2020-06-29-gcd%E7%AD%86%E8%A8%98-01/</guid>
            <description>關於GCD的一些筆記</description>
            <content type="html"><![CDATA[<h2 id="關於gcd">關於GCD</h2>
<p>什麼是GCD？GCD的全名為<strong>Grand Central Dispatch</strong></p>
<p>基本上就是執行緒管理中心。用比較不嚴謹的敘述來說的話，它就是幫助你處理多執行緒的管理器。
利用GCD，可以很方便地操控各種需要多執行緒的情境</p>
<h2 id="gcd的運作原理">GCD的運作原理</h2>
<blockquote>
<p>這邊姑且先不討論程式面的東西，先從抽象一點的地方來看。</p></blockquote>
<p>基本上來說，GCD掌控了Queue，而Queue包含了Work Item，最後WorkItem就是要執行的Closure</p>
<h3 id="queue">Queue</h3>
<p>Queue可以被翻成「佇列」，但是看了翻譯還是不知道是什麼意思。</p>
<p>可以想像成是去看電影的時候排隊的人潮，隊伍本身就是<strong>Queue</strong>。</p>
<p>先排進去的人，就可以先買票。這就是 <strong>FIFO ( First In First Out )</strong> 的概念。</p>
<p>Queue裡面放的是<strong>WorkItem</strong>，用買票的例子來解釋的話，就是<strong>你要買哪場的票</strong>這件事。</p>
<p>Queue又有分<strong>Serial</strong>跟<strong>Concurrent</strong>兩種</p>
<p><strong>Serial</strong>：就是一次只執行一個WorkItem，在這個WorkItem還沒執行完之前，不會取下一個來執行。</p>
<p><strong>Concurrent</strong>：自然就是相對於Serial，當第一個WorkItem被取出後，並不會等這個WorkItem被執行完，就接著取出下一個WorkItem，一直到這個Queue中所有WorkItem被拿出來執行為止（或是你吃光了所有系統可分配的Thread，也會被暫停）</p>
<hr>
<p>講完了Queue的類型，再來就是Queue要<strong>怎麼執行WorkItem</strong></p>
<p>這部分就分為 <strong>Sync（同步）<strong>跟</strong>Async（非同步）</strong> 兩種</p>
<p><strong>Sync</strong>：</p>
<p>當前的Queue會被擋住，不能往下執行，等待WorkItem被執行完以後，才會繼續往下執行。在這個時間點中只有一個Queue可以運作。</p>
<p>所以在用sync方法的時候一定要非常小心一個重點</p>
<p><strong>如果當前的執行中的Queue是Serial，而且你又要拿來做sync的動作的話，就會造成Deadlock</strong></p>
<p>舉個例子，下面這段程式如果用Main Queue來執行，就永遠不會執行到<code>print</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>DispatchQueue.main.sync {
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">&#34;never execute here&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>發生的原因很簡單，因為當系統執行到<code>DispatchQueue.main.sync</code>這段的時候，系統就知道「阿，要塞住當前的Queue」也就是MainQueue，然後又叫MainQueue去做事。但是這時候Main Queue已經被塞住了，又怎麼能去print呢？</p>
<p><strong>Async</strong>：非同步代表的是它<strong>不會塞住當前的執行緒</strong>
所以當Queue用非同步去執行WorkItem的時候，系統會開一條新的Thread去執行這個WorkItem，然後就繼續往下執行。</p>
<p>非同步程式可以保證當前的Thread執行不會被卡住，因為都會開一個新的Thread去執行WorkItem。但是非同步程式常常會遇到的就是他不會有返回值，所以很容易出現<code>Callback Hell</code>的狀況。不過這不是本篇要講的重點，後面寫<code>PromiseKit</code>或<code>RxSwift</code>的時候再說。</p>
<p>舉幾個例子，這可以直接貼到Playground裡面來執行</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">syncDemo</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;do something before sync&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    DispatchQueue.global().sync {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>..<span style="color:#ae81ff">5</span> { print(<span style="color:#e6db74">&#34;sync&#34;</span>) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;do something after sync&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>syncDemo()
</span></span></code></pre></div><p>結果是比較顯而易見的，就跟程式執行順序一致。</p>
<pre tabindex="0"><code>do something before sync
sync
sync
sync
sync
sync
sync
do something after sync
</code></pre><p>那麼用差不多的架構，只不過把sync換成async的話，會怎麼樣的？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">asyncDemo</span>() {
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;do something before async&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    DispatchQueue.global().async {       <span style="color:#75715e">// &lt;-- 注意這裡是async</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.</span>..<span style="color:#ae81ff">5</span> { print(<span style="color:#e6db74">&#34;async&#34;</span>) }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;do something after async&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>asyncDemo()
</span></span></code></pre></div><p>這邊就差很多了。</p>
<p>因為是另外開執行緒去做事，所以跟看到的結果就會有明顯差異</p>
<pre tabindex="0"><code>do something before async
do something after async
async
async
async
async
async
async
</code></pre><p>所以關於怎麼挑選自己要用的Queue，就可以從這四個裡面去兜出來。</p>
<p>具體的挑選就看自己的情境來決定。</p>
<p>本來還要寫一些DispatchGroup、訊號機等筆記的，但是寫的有點煩了。</p>
<blockquote>
<p>要改的東西太多了，那麼就改天吧。</p></blockquote>
]]></content>
        </item>
        
        <item>
            <title>SSH 基本設定</title>
            <link>/posts/2020-06-28-ssh-basic-setup/</link>
            <pubDate>Sun, 28 Jun 2020 18:34:47 +0800</pubDate>
            
            <guid>/posts/2020-06-28-ssh-basic-setup/</guid>
            <description>ssh到GitHub的時候，使用私鑰進行驗證</description>
            <content type="html"><![CDATA[<p>最近電腦爆了，懷疑應該是副廠的線造成的問題，</p>
<p>看樣子東西真的不能買便宜的（？</p>
<p>剛好也想說順便重新設定一些環境上的東西，只是這次要認真的寫筆記了&hellip;</p>
<p>之前的筆記都非常的零碎，重看的時候才會覺得好像少了很多東西。</p>
<blockquote>
<p>身為一個軟體工程師，寫一些坑人的筆記也是理所當然的事。</p></blockquote>
<p>正文開始</p>
<hr>
<h2 id="ssh到github的時候使用私鑰進行驗證">ssh到GitHub的時候，使用私鑰進行驗證</h2>
<p>具體步驟大概分為</p>
<ol>
<li><a href="/posts/2020-06-28-ssh-basic-setup/#%e7%94%a2%e7%94%9frsa%e7%9a%84%e5%85%ac%e7%a7%81%e9%91%b0">產生rsa的公私鑰</a></li>
<li><a href="/posts/2020-06-28-ssh-basic-setup/#%e8%a8%ad%e5%ae%9assh%e7%9a%84config">設定ssh的config</a> （optional）</li>
<li><a href="/posts/2020-06-28-ssh-basic-setup/#%e7%99%bb%e5%85%a5Github%e4%b8%a6%e4%b8%94%e5%8a%a0%e5%85%a5%e5%89%9b%e5%89%9b%e7%94%a2%e7%94%9f%e7%9a%84%e5%85%ac%e9%91%b0">登入Github並且加入剛剛產生的公鑰</a> （手動）</li>
<li><a href="/posts/2020-06-28-ssh-basic-setup/#%e6%b8%ac%e8%a9%a6%e9%80%a3%e7%b7%9a">測試連線</a></li>
</ol>
<hr>
<h3 id="產生rsa的公私鑰">產生rsa的公私鑰</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ssh-keygen
</span></span></code></pre></div><p>過程中會問兩個問題</p>
<ol>
<li>產生的公私鑰要放的位置</li>
<li>設定密碼 ( passphrase )</li>
</ol>
<p>公私鑰的位置如果直接按Return的話，就會存在預設的位置。</p>
<p>預設位置為：<code>/Users/username/.ssh/id_rsa</code></p>
<blockquote>
<p>這邊的username請自行修改成你的帳號，不是真的路徑喔&hellip;</p></blockquote>
<p>不然也可以自行輸入要存放的位置，例如：</p>
<p><code>/Users/username/.ssh/rsa-for-github</code></p>
<blockquote>
<p>不過這邊要留意一點：不能用tab自動補全，在輸入的時候要注意大小寫跟拼字</p></blockquote>
<p>密碼的部分應該是為了多人共用電腦而設計的，避免使用別人的私鑰去亂搞。</p>
<p>如果輸入密碼的話就每次使用ssh連接時都需要打密碼。</p>
<p>這部分我就沒特別研究了，有需要的請自行研究。</p>
<p>完成以後會產生一組公私鑰檔案，例如</p>
<p><code>rsa-for-github.pub</code> and <code>rsa-for-github</code></p>
<blockquote>
<p>沒有<code>.pub</code>的檔案就是私鑰，請好好保管。</p></blockquote>
<hr>
<h3 id="設定ssh的config">設定ssh的config</h3>
<p>如果在第一步中使用預設位置的話，這一步就可以跳過，如果還有興趣就隨便看看吧</p>
<p>用不同鑰匙的好處，就跟你不同網站用不同密碼是一樣的概念，</p>
<p>減少私鑰遺失後全部都被攻破的風險。</p>
<p>缺點當然是要自行管理這些檔案，管理的方法就是用config來告訴ssh要用哪一個私鑰來驗證。</p>
<p>因為預設的ssh會去讀<code>id_rsa</code>作為私鑰去驗證，所以如果不用config讓ssh知道要用哪一把鑰匙去做驗證，不管怎麼都入都是失敗的喔。</p>
<p>基本上我常用的大概就幾個</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Host         <span style="color:#75715e"># 用來連線的 alias 名稱</span>
</span></span><span style="display:flex;"><span>HostName     <span style="color:#75715e"># host domain 或 ip</span>
</span></span><span style="display:flex;"><span>Port         <span style="color:#75715e"># host 的 SSH port</span>
</span></span><span style="display:flex;"><span>IdentityFile <span style="color:#75715e"># 私鑰位置</span>
</span></span><span style="display:flex;"><span>User         <span style="color:#75715e"># 登入帳號</span>
</span></span></code></pre></div><p>舉幾個例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># Github</span>
</span></span><span style="display:flex;"><span>Host github.com
</span></span><span style="display:flex;"><span>HostName github.com
</span></span><span style="display:flex;"><span>IdentityFile ~/.ssh/rsa_for_github
</span></span><span style="display:flex;"><span>User git
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Raspberry</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 因為我有買樹莓派回來玩，如果不用這樣登入的話，每次都是要打帳號密碼，很煩。</span>
</span></span><span style="display:flex;"><span>Host raspbian
</span></span><span style="display:flex;"><span>HostName 192.168.1.123
</span></span><span style="display:flex;"><span>IdentityFile ~/.ssh/rsa_for_rpi
</span></span><span style="display:flex;"><span>User pi
</span></span></code></pre></div><hr>
<h3 id="登入github並且加入剛剛產生的公鑰">登入Github並且加入剛剛產生的公鑰</h3>
<p>可以先用<code>cat</code>指令來顯示公鑰內容，然後再把公鑰貼到Github的SSH Key欄位中</p>
<p><img src="/github-setting-ssh-step-1.png" alt="image"></p>
<p><img src="/github-setting-ssh-step-2.png" alt="image"></p>
<p><img src="/github-setting-ssh-step-3.png" alt="image"></p>
<p>這邊比較簡單就放三張圖自己研究一下就夠了。</p>
<p>這邊補充一下，如果要用命令將公鑰加入到目標server中的話（例如樹莓派）可以用以下的命令來執行。</p>
<p>不確定能不能用命令把公鑰加入到Github中，這部分沒特別研究。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e"># 語法：</span>
</span></span><span style="display:flex;"><span>ssh-copy-id user@host
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 如果不是用預設的名稱，就要加入參數 i，用來指定IdentityFile</span>
</span></span><span style="display:flex;"><span>ssh-copy-id -i ~/.ssh/rsa-for-rpi.pub user@host
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 範例</span>
</span></span><span style="display:flex;"><span>ssh-copy-id pi@192.168.1.123
</span></span><span style="display:flex;"><span>ssh-copy-id -i ~/.ssh/rsa-for-rpi.pub pi@192.168.1.123
</span></span></code></pre></div><hr>
<h3 id="測試連線">測試連線</h3>
<p>根據Github的<a href="https://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection">線上文件</a>，只要透過下面這行命令即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>ssh -T git@github.com
</span></span></code></pre></div><p>只要最後出現的是下面這樣就算成功了，至於沒出現的話，就看看有哪些地方做錯了吧。</p>
<pre tabindex="0"><code>&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not
&gt; provide shell access.
</code></pre><h2 id="參考網頁">參考網頁</h2>
<p><a href="">https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/</a></p>
<p><a href="">https://xenby.com/b/220-教學-產生ssh-key並且透過key進行免密碼登入</a></p>
<p><a href="">https://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection</a></p>
]]></content>
        </item>
        
        <item>
            <title>Hello World</title>
            <link>/posts/2020-06-28-hello-world/</link>
            <pubDate>Sun, 28 Jun 2020 16:06:07 +0800</pubDate>
            
            <guid>/posts/2020-06-28-hello-world/</guid>
            <description>Hello Hugo</description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
    </channel>
</rss>
