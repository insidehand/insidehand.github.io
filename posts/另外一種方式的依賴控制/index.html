<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.100.2" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>另外一種方式的依賴控制&nbsp;&ndash;&nbsp;Insidehand</title><link rel="stylesheet" href="/css/core.min.4f9033ab7c3cd76c549c46456b7b316174dfd5f0c35d4a499145b7cc3d4591088a9e9cbad553bdbef09fba207d9671bb.css" integrity="sha384-T5Azq3w812xUnEZFa3sxYXTf1fDDXUpJkUW3zD1FkQiKnpy61VO9vvCfuiB9lnG7"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="另外一種方式的依賴控制" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">Insidehand</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">另外一種方式的依賴控制</h1><p class="article date">2021-10-11</p></section><article class="article markdown-body"><h2 id="什麼是依賴為什麼要管理">什麼是依賴，為什麼要管理？</h2>
<blockquote>
<p>任何你不能控制的物件，都是隱藏的依賴</p>
</blockquote>
<p>具體來說，如果程式完全不寫測試，那麼其實就不用考慮依賴的問題。</p>
<p>要管理依賴的理由在於給測試一個介入的途徑。</p>
<p>例如說有一個物件是用來追蹤聖誕老人，裡面判斷他有沒有上班。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SantaClausTracker</span> {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isWorking</span>() -&gt; Bool {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> today = Date()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> month = Calendar.current.components(.month, today)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> day = Calendar.current.components(.day, today)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> month == <span style="color:#ae81ff">12</span> <span style="color:#f92672">&amp;&amp;</span> day == <span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>顯然，要這個方法回傳<code>true</code>的話，就只能在聖誕節當天進行測試。
其他日子回傳都是<code>false</code>。</p>
<p>這個方法裡面有兩個依賴，一個是<code>Date()</code>，另一個則是<code>Calendar.current</code>。
如果想要把這些依賴變得可控，那麼就是要透過外部傳入。也就是依賴注入（dependency injection）</p>
<p>傳統的方法有三：</p>
<ol>
<li>建構子注入</li>
<li>屬性注入</li>
<li>方法參數注入</li>
</ol>
<p>名稱應該足以描述相對應的行為，就不多贅述了。</p>
<p>換言之，在程式碼中，只要是<code>使用</code>的物件，都要記得可以替換。
舉個例子</p>
<pre tabindex="0"><code>(X
func somefunction() {
    Date() 
}

(O
func somefunction(date: Date) {
    date 
}

(X
func somefunction() {
    URLSession.share
}

(🔺
func somefunction(session: URLSession) {
    session
}
</code></pre><p>那麼，顯然會出現的問題就是「<strong>依賴要怎麼來</strong>」</p>
<p>例如說一個App畫面堆疊是這樣</p>
<p><del>先不討論畫面層級太深的問題</del>這可以看一個精彩的影片「<a href="https://www.ted.com/talks/david_pogue_simplicity_sells"target="_blank">至簡暢銷</a>」</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
View1 --&gt; View2 --&gt; View3 --&gt; View4
</code></pre><p>今天View4有呼叫API的需要，View2 , 3沒有。
要present View4只能夠過View3（MVC）或是View3的Coordinator（MVVM C）
勢必View2, 3都必須要攜帶一個用不到的物件。</p>
<p>當今天底層越多，依賴拆分的越細，就中間的層級就容易要傳遞一些用不到的物件。</p>
<p><strong>久了就不容易維護，不容易維護就等於隱藏的Bug</strong></p>
<p>以前寫過類似的程式碼，中間傳遞的參數多了，就需要使用DTO來打包，多一層又顯得冗余。</p>
<p>這時候就看到一個突破天際的想法<a href="https://vimeo.com/291588126"target="_blank">How to control the World</a></p>
<p><strong>強烈建議看影片</strong></p>
<p><strong>強烈建議看影片</strong></p>
<p><strong>強烈建議看影片</strong></p>
<p>先來看看實作，把需要的依賴宣告在一個struct中</p>
<pre tabindex="0"><code>struct World {
  var date = { Date() }
}
</code></pre><blockquote>
<p>這邊要注意的是並不是透過「方法」來取值，例如說
<code>func getDate() -&gt; Date { ... }</code>
因為方法的實作是不可異動的，本質上還是依賴，只是把依賴集中到一個地方管理。</p>
<p>也不是直接是一個Date屬性
因為當你存取Current.date時，每次取的都是不一樣的值
如果想要每次都取得同一個時間的話，就做不到這個需求</p>
<p>當然這邊也可以把這個<code>struct</code>改寫成<code>protocol</code>，然後實作不同的物件來提供不同的測試需要，不過那就是另外一回事了。</p>
</blockquote>
<p>說回正題，當你宣告了這樣的<code>struct</code>，你還需要一個<strong>全域</strong>的<strong>變數</strong></p>
<pre tabindex="0"><code>var Current = World()
</code></pre><blockquote>
<p>這是一個<code>Singleton</code>！<del>皮諾可，這個直接電死</del></p>
</blockquote>
<p>別急，這時候這個設計神的地方來了。</p>
<p>用上面的範例來實作的話就會變這樣</p>
<pre tabindex="0"><code>struct SantaClusTracker {
  
  func isWorking() -&gt; Bool {
    //暫時先改一個，baby step
    let today = Current.date()
    let month = Calendar.current.components(.month, today)
    let day = Calendar.current.components(.day, today)
    return month == 12 &amp;&amp; day == 25
  }

}
</code></pre><p>因為<code>Current</code>是一個<code>var</code>，所以裡面的屬性是可以異動的。
因為<code>date</code>是一個<code>回傳Date的function</code>，所以實作內容也是可以異動的</p>
<p>今天需要測試的時候，可以直接對<code>Current</code>設值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test_Date_Is_Christmas_SantaClausTracker_isWorking_should_return_true</span>() <span style="color:#66d9ef">throws</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 3A原則，具體可以參考91的文章或是聽他的課！獲益良多 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Arrange</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> target = SantaClausTracker()
</span></span><span style="display:flex;"><span>  Current.date = { 
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">let</span> formatter = DateFormatter()
</span></span><span style="display:flex;"><span>     formatter.dateFormat = <span style="color:#e6db74">&#34;yyyy/MM/dd&#34;</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> formatter.date(string: <span style="color:#e6db74">&#34;2021/12/25&#34;</span>)<span style="color:#f92672">!</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Action</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> actual = target.isWorking()
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Assert</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> expect = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  XCTAssertEqual(actual, expect)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如此，就算是在其他日子，也能檢查在聖誕節的時候是不是會回傳<code>true</code></p>
<p>這邊先討論幾個問題</p>
<ol>
<li>Singleton不是不好，為什麼要用？</li>
<li>為什麼不用介面隔開？</li>
<li>全域變數很危險，不應該用不是嗎？</li>
</ol>
<h3 id="singleton不是不好為什麼要用">Singleton不是不好，為什麼要用？</h3>
<p>Singleton並不是不好，不好的話Apple還到處放不是很奇怪？</p>
<p><code>URLSession.shared</code></p>
<p><code>UserDefaults.standard</code></p>
<p><code>FileManager.default</code></p>
<p>Singleton的問題在於它是一個實體型別，無法被抽象化。也就是無法在測試中被替換。當你今天在程式碼中放了<code>URLSession.shared</code>以後，就註定了他一定會去走真實的網路（用intercepter擋掉另當別論），而沒辦法用<code>MockURLSession</code>來進行替換</p>
<h3 id="為什麼不用介面隔開">為什麼不用介面隔開？</h3>
<p>在看這個影片之前，我也是用<code>protocol</code>來進行區隔，這也有一個大神的文章可以參考<a href="https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k"target="_blank">歡迎來到真實世界</a></p>
<p>先來談談如果用介面隔開URLSession，要做多少動作？</p>
<ol>
<li>製作一個介面<code>URLSessionProtocol</code>，方法簽章要跟URLSession中要呼叫的方法一致</li>
<li>讓URLSession擴充<code>URLSessionProtocol</code>，因為方法已經存在，所以不用另外實作。</li>
<li>製作一個測試在用的物件<code>MockURLSession</code>，實作介面<code>URLSessionProtocol</code>，裡面不涉及網路存取，直接回傳值。</li>
<li>將原本程式碼呼叫<code>URLSession.shared</code>的地方全部抽換掉</li>
<li>在測試中將<code>MockURLSession</code>注入到測試目標中</li>
</ol>
<p>首先，這個做法對程式碼改動幅度比較大，當早期沒做，後面要抽換的時候改動幅度就會很大，也是存在風險。</p>
<p>其次，如果介面裡面的方法開始變多以後，一個新的Mock物件實作起來不容易。</p>
<blockquote>
<p>例如說一個資料庫存取介面，有四個方法CRUD</p>
<p>那麼建立一個新的Mock物件就要實作四個方法。</p>
<p>而一個正常的介面方法都不止四個</p>
</blockquote>
<h3 id="全域變數很危險不應該用不是嗎">全域變數很危險，不應該用不是嗎？</h3>
<p>全域變數的危險之處在於「<strong>你不知道什麼時候被改動</strong>」</p>
<p>誠然，設定為變數是存在風險的，但是不應該把<code>Current</code>當成是一個傳遞、暫存參數的地方。而是一個依賴保管區（Production時）、依賴注入區（Develop時）</p>
<p>說回這個方法</p>
<p>如果今天要測試使用者登入「<strong>成功</strong>」與「<strong>失敗</strong>」的情境</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserAPIClient</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void ) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> url = URL(string: <span style="color:#e6db74">&#34;API Path&#34;</span>)<span style="color:#f92672">!</span> <span style="color:#75715e">// &lt;-- 這裡一定run time error</span>
</span></span><span style="display:flex;"><span>        URLSession.shared.dataTask(with: url) { data, <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            complectionHandler(data == <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                UserAPIClient().login(account: <span style="color:#e6db74">&#34;account&#34;</span>, password: <span style="color:#e6db74">&#34;password&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>UserAPIClient</code>有一個一定會在run time炸掉的地方，那就是<code>URL(string: &quot;API Path&quot;)!</code></p>
<p>假想這是Server暫時不可用，或是網路斷線的情境吧。</p>
<p>那這種時候就不用測試了嗎？沒錯！<del>後台修好再叫我</del></p>
<p>當然不可能，所以這時候就需要脫離實際環境來測試功能是否正常。</p>
<p>用<code>protocol</code>的方式來進行脫鉤是這樣實作的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#75715e">//1. 定義協議</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protocol</span> <span style="color:#a6e22e">UserAPIClientProtocol</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//2. 讓原本的物件擴充這個協議</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extension</span> <span style="color:#a6e22e">UserAPIClient</span>: UserAPIClientProtocol { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//3. 建立測試物件，因為測試情境有「成功」「失敗」，所以回傳值用建構注入</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MockUserAPIClient</span>: UserAPIClientProtocol {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> loginResult: Bool
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">func</span> <span style="color:#a6e22e">login</span>(account: String, password: String, complectionHandler: @escaping (Bool) -&gt; Void ) {
</span></span><span style="display:flex;"><span>      complectionHandler(loginResult)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//4. 將原本的型別用介面抽換（呼叫的時候要注入）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> userAPIClient: UserAPIClientProtocol
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                userAPIClient.login(account: <span style="color:#e6db74">&#34;acc&#34;</span>, password: <span style="color:#e6db74">&#34;pass&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//5. 修改呼叫端</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView_Previews</span>: PreviewProvider {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> previews: some View {
</span></span><span style="display:flex;"><span>        ContentView(userAPIClient: MockUserAPIClient(loginResult: <span style="color:#66d9ef">true</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果用World來控制的話，是這個樣子的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">UserAPI</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> login = UserAPIClient().login(account:password:complectionHandler:)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">World</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> userAPI = UserAPI()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> Current = World()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView</span>: View {
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    @State <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">var</span> loginResult: Bool = <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> body: some View {
</span></span><span style="display:flex;"><span>        Text(<span style="color:#e6db74">&#34;Login </span><span style="color:#e6db74">\(</span>loginResult ? <span style="color:#e6db74">&#34;Success&#34;</span> : <span style="color:#e6db74">&#34;Failure&#34;</span><span style="color:#e6db74">)</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>            .onAppear {
</span></span><span style="display:flex;"><span>                Current.userAPI.login(<span style="color:#e6db74">&#34;account&#34;</span>, <span style="color:#e6db74">&#34;password&#34;</span>) { result <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>                    loginResult = result
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//修改呼叫端</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ContentView_Previews</span>: PreviewProvider {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">var</span> previews: some View {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//正常不會在這邊修改，這邊只是懶得把資料切乾淨所以放著舉例一下</span>
</span></span><span style="display:flex;"><span>        Current.userAPI.login = { <span style="color:#66d9ef">_</span>, <span style="color:#66d9ef">_</span>, callback <span style="color:#66d9ef">in</span>
</span></span><span style="display:flex;"><span>            callback(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ContentView()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>看起來有點差異，但是好像又差異不大？
當你再遇到這樣的需求時</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
View1 --&gt; View2 --&gt; View3 --&gt; View4
</code></pre><p>View2, 3就不需要攜帶<code>UserAPIClient</code>跑來跑去了</p>
<p><strong>最重要的是</strong>
當你的測試情境需要不同的回傳值時，不再需要像上面的<code>MockUserAPIClient</code>一樣透過各種注入，考慮各種測試情境要呼叫方法時的通用性，而是可以直接針對特定方法改寫方法實作內容。</p>
<h2 id="參考文章">參考文章：</h2>
<p><a href="https://vimeo.com/291588126"target="_blank">https://vimeo.com/291588126</a></p>
<p><a href="https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k"target="_blank">https://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k</a></p>
</article><section class="article labels"><a class="tag" href=/tags/swift/>Swift</a><a class="tag" href=/tags/dependency/>Dependency</a><a class="tag" href=/tags/global-variable/>Global Variable</a></section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0simulator%E7%9A%84document%E4%BD%8D%E7%BD%AE/"><span class="iconfont icon-article"></span>如何快速找到Simulator的Document位置</a></p><p><a class="link" href="/posts/gcd%E7%AD%86%E8%A8%98-01/"><span class="iconfont icon-article"></span>關於GCD的一些筆記-1</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Insidehand</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>