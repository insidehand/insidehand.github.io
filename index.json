[{"content":"最近被之前的同事找回以前離職的公司去幫忙收拾各種前人留下來的爛攤子\n花了一段時間以後，突然有所體悟。\n在老闆、主管、工程師都是新手的情況下，\n在一個公司是新創、員工是新手、老闆不懂技術狀況下\n一起合作下去是有一定程度上的難處的。\n這邊想說也想說做個簡單的記錄，讓自己以後有些資料可以參考。 也希望這些資料可以對其他人產生幫助。\n不過這邊都是以工程師的角度出發， 對於一個資方要怎麼面對勞方我就沒輒了啊。\n關於產品 工程師基本也等於魔術師，基本上就是把想像中的產品具現化出來。 能夠透過一些包裝、手法讓使用者有完全不一樣的使用體驗。\n但工程師不是魔法師，並不能夠透過念咒來無中生有，跳過研發直接變出產品。 工程師也不會通靈，並不知道客戶、老闆到底想要什麼東西。\n所以在跟工程師討論產品開發的過程中，記得不要畫餅，那是慰留工程師的時候才要說的。\n直接講說希望產品具備什麼功能、想要長什麼樣子、要返回什麼樣的資料就好了。\n當然這邊也並不是說要細化到每一個細節，包含畫面什麼顏色，資料要有哪些屬性等等。 有些規劃還是要由工程師來完成的。\n舉個例子吧，這間公司的老闆常常說「要做一個某某產品」，但是具體的細節一概不知。 包含目標客群有哪些、需要用到哪些技術、預計什麼時候上市。\n這在大公司可以，但是在小公司不行。\n因為在大公司有其他的主管負責分析、研究、規劃等功能，有資源能夠投入，失敗了也並不會影響到公司的生計。\n小公司一旦賭錯，整個公司都會直接陪進去。\n至少，大方向要給出來。線上的還是離線的，賣點是硬體還是軟體，商用的還是民用的。\n關於文件 所有產品、功能在具現化的過程都是不斷地溝通討論。 產品在具現化的過程中必須要留下一些資料。 基本的就是研究數據、使用情境、開發環境。\n這部分都統稱為「文件」\n文件的撰寫與程式碼的註解基本保持一個原則： 「不要告訴我What，告訴我Why。」\n舉個「沒用」的例子\n// 設定背景顏色，如果someCondition為真為黑色，為假則是藍色 view.background = someCondition ? .black : .blue 這種註解，不寫會更好。因為程式碼就能看得出來。 程式碼看不出來的是：「為什麼是藍色跟黑色」。\n開發過程中留下的文件也一樣。\n寫下「為什麼這樣寫」比起「這裡寫了什麼」更為重要。\n開發文件一定要留。可以不用畫多專業的UML圖、做多精美的PPT、Word。 但至少這功能想表達什麼要寫個文件。\n關於程式碼 對於程式碼來說，一定要有一套Coding Style的工具，而且共同開發同一個專案的工程師必須要認同這裡面的一些規則。\n至於Coding Style工具的選擇，基本上每套語言幾乎都會有屬於自己的lint工具以及官方的推薦的naming規則。\n套用style的時機，可以設計在IDE要build code的時候，或是版控commit之前。\n程式碼有幾個注意點：\n註解掉的程式碼請直接刪除，請用版控保護你的程式碼，而不是靠註解掉的程式碼。 IDE自動產生的註解記得拿掉，例如說前人有很多的TODO: //Auto generate method stub留在那邊，不知道為什麼。 不要留下`20220603 modified這樣子的程式碼在上面。除了告訴後面的人你不會用版控以外，並沒有任何幫助。 變數命名不要命一些aa bb，也不要留一堆print(++++)之類的東西 不要在程式碼裡面留下常數，全部都請拿去定義。 3.14請定義成pi errorCode請定義成有意義的名稱 關於版本控制 版本控制，我現在的理解就是：「所有的記錄都可以被追蹤」\n這個概念必須要擴張到所有的產品、文件、記錄上。\n版本控制，重要的是控制，而並非版本。\n這邊說的版控並不是「放到版控系統」這麼簡單的事情。\n而是應該具有透過現行的資訊，判斷出當前使用的版本的能力。\n例如：\n測試production code中的某個bug，應該從主幹上取得最新的版本來進行測試。 要測試release code相關功能，應該從對應的分支取得最新版本來測試。 客戶反映了問題，應該要能透過客戶的版本號來檢查問題是否被處理過。 版本控制有幾個要點：\n沒有用的程式（功能、分支、文件、資料夾、etc.）就不要留，但是刪除的節點記得留下說明。 上版的程式碼一定要有tag 不要取自己的名字當成分支名稱，毫無意義。 git flow要就好好做，不要污染develop。占著茅坑不拉屎。 韌體、前端、移動端、後端、資料庫schema一定要有對應， 而對應只能靠版本號碼，版本號碼只能靠版控或文件。\n後面想到再寫吧。\n一樣舉個例子：\n這家公司的所有，對，是所有。所有的東西都沒有版控。 但是這公司的版控並不具備相關的能力，或者說，工程師並沒有相對應的概念。\n上線的Server程式可能在develop分支、某個feature分支、兩三個版本前的主幹節點都有可能；開發中的硬體可能具備某些功能，也可能不具備，可能修了某些問題，也可能沒修復。族繁不及備載\n其他一些觀察到的狀況 資料庫的使用者、帳號、密碼請設計規範一點，不要寫一堆用戶與資料卻都沒有用到。\n對於不熟悉的東西不要亂改，去隨便設定防火牆或是更換預設IP, Port, etc.的設定。\n如果為了安全性要進行修改，就把整套的功能都研究完再來處理。\n情境：\n遇到電信公司改IP，結果無法登入遠端機器。最後發現不只在管理區有擋，還在遠端機器內部寫死允許連線的IP。而且沒有留下文件 Jenkins的自動建制，因為Gitlab的port改過了，但是沒有去修改其他服務的對應port，所以CD自動壞掉。 ","permalink":"/posts/article/2022-06-19-%E6%96%B0%E5%85%AC%E5%8F%B8%E6%87%89%E8%A9%B2%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%96%8B%E7%99%BC%E8%A7%80%E5%BF%B5/","summary":"最近被之前的同事找回以前離職的公司去幫忙收拾各種前人留下來的爛攤子\n花了一段時間以後，突然有所體悟。\n在老闆、主管、工程師都是新手的情況下，\n在一個公司是新創、員工是新手、老闆不懂技術狀況下\n一起合作下去是有一定程度上的難處的。\n這邊想說也想說做個簡單的記錄，讓自己以後有些資料可以參考。 也希望這些資料可以對其他人產生幫助。\n不過這邊都是以工程師的角度出發， 對於一個資方要怎麼面對勞方我就沒輒了啊。\n關於產品 工程師基本也等於魔術師，基本上就是把想像中的產品具現化出來。 能夠透過一些包裝、手法讓使用者有完全不一樣的使用體驗。\n但工程師不是魔法師，並不能夠透過念咒來無中生有，跳過研發直接變出產品。 工程師也不會通靈，並不知道客戶、老闆到底想要什麼東西。\n所以在跟工程師討論產品開發的過程中，記得不要畫餅，那是慰留工程師的時候才要說的。\n直接講說希望產品具備什麼功能、想要長什麼樣子、要返回什麼樣的資料就好了。\n當然這邊也並不是說要細化到每一個細節，包含畫面什麼顏色，資料要有哪些屬性等等。 有些規劃還是要由工程師來完成的。\n舉個例子吧，這間公司的老闆常常說「要做一個某某產品」，但是具體的細節一概不知。 包含目標客群有哪些、需要用到哪些技術、預計什麼時候上市。\n這在大公司可以，但是在小公司不行。\n因為在大公司有其他的主管負責分析、研究、規劃等功能，有資源能夠投入，失敗了也並不會影響到公司的生計。\n小公司一旦賭錯，整個公司都會直接陪進去。\n至少，大方向要給出來。線上的還是離線的，賣點是硬體還是軟體，商用的還是民用的。\n關於文件 所有產品、功能在具現化的過程都是不斷地溝通討論。 產品在具現化的過程中必須要留下一些資料。 基本的就是研究數據、使用情境、開發環境。\n這部分都統稱為「文件」\n文件的撰寫與程式碼的註解基本保持一個原則： 「不要告訴我What，告訴我Why。」\n舉個「沒用」的例子\n// 設定背景顏色，如果someCondition為真為黑色，為假則是藍色 view.background = someCondition ? .black : .blue 這種註解，不寫會更好。因為程式碼就能看得出來。 程式碼看不出來的是：「為什麼是藍色跟黑色」。\n開發過程中留下的文件也一樣。\n寫下「為什麼這樣寫」比起「這裡寫了什麼」更為重要。\n開發文件一定要留。可以不用畫多專業的UML圖、做多精美的PPT、Word。 但至少這功能想表達什麼要寫個文件。\n關於程式碼 對於程式碼來說，一定要有一套Coding Style的工具，而且共同開發同一個專案的工程師必須要認同這裡面的一些規則。\n至於Coding Style工具的選擇，基本上每套語言幾乎都會有屬於自己的lint工具以及官方的推薦的naming規則。\n套用style的時機，可以設計在IDE要build code的時候，或是版控commit之前。\n程式碼有幾個注意點：\n註解掉的程式碼請直接刪除，請用版控保護你的程式碼，而不是靠註解掉的程式碼。 IDE自動產生的註解記得拿掉，例如說前人有很多的TODO: //Auto generate method stub留在那邊，不知道為什麼。 不要留下`20220603 modified這樣子的程式碼在上面。除了告訴後面的人你不會用版控以外，並沒有任何幫助。 變數命名不要命一些aa bb，也不要留一堆print(++++)之類的東西 不要在程式碼裡面留下常數，全部都請拿去定義。 3.14請定義成pi errorCode請定義成有意義的名稱 關於版本控制 版本控制，我現在的理解就是：「所有的記錄都可以被追蹤」","title":"新公司應該要注意的開發觀念"},{"content":"如果要用kobo來看txt或是從calibre導入書籍有諸多不便，\n有聽說其他閱讀軟體可以抓但是有點懶得弄。\n後來看到大神的blog，有統整了怎麼安裝第三方閱讀器，就順便抓了一下。\nKoreader\u0008功能是真的多，但是相對的電力也是噴很快。不過書本的啟動速度還是比官方慢了一點。\n但是傳資料還是一個痛點。\n經歷各種不方便，後來無意中發現已經有大神寫好一個工具方便使用，那就是Nickel Menu 這就是本篇的重點。\n基本上先參考這個連結來安裝第三方閱讀器，具體要安裝哪一個就看個人需求。 安裝第三方閱讀器\n安裝完以後右下角會出現一個Nickel Menu的功能選項，裡面的選項是可以自訂的。下面會說明\n流程概略是這樣：\n安裝第三方閱讀器 打開KOReader 在KOReader中打開SSH Server 連線進Kobo，進到/mnt/onboard/.adds/nm資料夾 建立一個檔案，檔名自訂，不要加上副檔名不確定加了會怎麼樣，可以自行嘗試，概不負責啊 加入想要的命令 整體操作大致流程是這樣，前三點就不說了，直接從第四點往下講\n進到/mnt/onboard/.adds/nm這邊後，裡面基本上會有一個doc檔， 裡面就是文件說明。\n建議可以用cp複製一份以後，直接用vi或是nano來編輯。 下面有很多的範例可供參考\n這邊列一些我覺得比較實用的\n# Reboot menu_item :main :Reboot :power :reboot # Refresh library menu_item :main :Import books :nickel_misc :rescan_books_full # Force Wifi On/Off menu_item :main :Force Wi-Fi On (toggle) :nickel_setting :toggle:force_wifi # Toggle Telnet menu_item :main :Telnet (toggle) :cmd_output :500:quiet :/usr/bin/pkill -f \u0026#34;^/usr/bin/tcpsvd -E 0.0.0.0 2023\u0026#34; chain_success:skip:5 chain_failure :cmd_spawn :quiet :/bin/mount -t devpts | /bin/grep -q /dev/pts || { /bin/mkdir -p /dev/pts \u0026amp;\u0026amp; /bin/mount -t devpts devpts /dev/pts; } chain_success :cmd_spawn :quiet :exec /usr/bin/tcpsvd -E 0.0.0.0 2023 /usr/sbin/telnetd -i -l /bin/login chain_success :dbg_toast :Started Telnet server on port 2023 chain_failure :dbg_toast :Error starting Telnet server on port 2023 chain_always:skip:-1 chain_success :dbg_toast :Stopped Telnet server on port 2023 # Open FTP menu_item :main :FTP :cmd_spawn :quiet:/usr/bin/pkill -f \u0026#34;^/usr/bin/tcpsvd -E 0.0.0.0 1021\u0026#34; || true \u0026amp;\u0026amp; exec /usr/bin/tcpsvd -E 0.0.0.0 1021 /usr/sbin/ftpd -w -t 30 /mnt/onboard chain_success :dbg_toast :Started FTP server for KOBOeReader partition on port 1021. # Show IP menu_item :main :IP Address :cmd_output :500:/sbin/ifconfig | /usr/bin/awk \u0026#39;/inet addr/{print substr($2,6)}\u0026#39; mac端基本設定 這邊是用macOS，但是基於安全性macOS已經移除了telnet這個套件 所以要先安裝telnet，這邊推薦用inetutils，裡面就包含了telnet, FTP等\n安裝語法： brew install inetutils\n安裝完成後就可以用 telnet kobo-reader-ip連線進Kobo了 帳號是root，沒有密碼。 因為是root，各種操作請自行小心！\nOfficial site\n參考連結\n","permalink":"/posts/article/2021-11-11-kobo-nickel-menu%E7%9A%84%E7%94%A8%E6%B3%95/","summary":"如果要用kobo來看txt或是從calibre導入書籍有諸多不便，\n有聽說其他閱讀軟體可以抓但是有點懶得弄。\n後來看到大神的blog，有統整了怎麼安裝第三方閱讀器，就順便抓了一下。\nKoreader\u0008功能是真的多，但是相對的電力也是噴很快。不過書本的啟動速度還是比官方慢了一點。\n但是傳資料還是一個痛點。\n經歷各種不方便，後來無意中發現已經有大神寫好一個工具方便使用，那就是Nickel Menu 這就是本篇的重點。\n基本上先參考這個連結來安裝第三方閱讀器，具體要安裝哪一個就看個人需求。 安裝第三方閱讀器\n安裝完以後右下角會出現一個Nickel Menu的功能選項，裡面的選項是可以自訂的。下面會說明\n流程概略是這樣：\n安裝第三方閱讀器 打開KOReader 在KOReader中打開SSH Server 連線進Kobo，進到/mnt/onboard/.adds/nm資料夾 建立一個檔案，檔名自訂，不要加上副檔名不確定加了會怎麼樣，可以自行嘗試，概不負責啊 加入想要的命令 整體操作大致流程是這樣，前三點就不說了，直接從第四點往下講\n進到/mnt/onboard/.adds/nm這邊後，裡面基本上會有一個doc檔， 裡面就是文件說明。\n建議可以用cp複製一份以後，直接用vi或是nano來編輯。 下面有很多的範例可供參考\n這邊列一些我覺得比較實用的\n# Reboot menu_item :main :Reboot :power :reboot # Refresh library menu_item :main :Import books :nickel_misc :rescan_books_full # Force Wifi On/Off menu_item :main :Force Wi-Fi On (toggle) :nickel_setting :toggle:force_wifi # Toggle Telnet menu_item :main :Telnet (toggle) :cmd_output :500:quiet :/usr/bin/pkill -f \u0026#34;^/usr/bin/tcpsvd -E 0.0.0.0 2023\u0026#34; chain_success:skip:5 chain_failure :cmd_spawn :quiet :/bin/mount -t devpts | /bin/grep -q /dev/pts || { /bin/mkdir -p /dev/pts \u0026amp;\u0026amp; /bin/mount -t devpts devpts /dev/pts; } chain_success :cmd_spawn :quiet :exec /usr/bin/tcpsvd -E 0.","title":"Kobo Nickel Menu的用法"},{"content":" 基本命令 stash clean 應用篇 重新命名 老實說，Git很好用，但是有很多突發狀況下，Git的命令常常會想不太起來或是忘記怎麼用。\n這邊有印象就寫個筆記\n基本命令 stash 如果今天突然有問題要修改，但是你現在的code又還不能commit 那麼就適合用stash來保存這些異動\n基本命令：\n# 保存當前所有異動 git stash save # 讀取stash i # 請善用自動補完，i代表第幾個stash，不是真的命令 # 這兩個命令基本上是一樣的，所以寫在一起 # 差別在於pop取得異動後，會直接刪掉stash中的備份，而apply不會 # 所以如果你只是想「取出來看看」，建議用apply git stash pop stash@\\{i\\} git stash apply stash@\\{i\\} # 列出所有的stash git stash list # 拋棄stash i git stash drop stash@\\{i\\} # 顯示stash i有哪些檔案有異動 # 如果要更精細的看異動內容，就加上 -p 這個變數 git stash show stash@\\{i\\} 常用命令：\n# 用來保存當前所有的異動，message為這個stash的說明，或著說註解。 # 在 git stash list 的時候會看得到 git stash save -m \u0026#39;message\u0026#39; # 互動式的stash，如果只要stash部分異動，那麼就可以用這個命令。 # 這會把有異動的檔案找出來，然後分片段詢問要不要保留 # 基本上的git add --patch 的用法一樣 git stash save --patch # 當你只想保留特定檔案，但是不想用add --patch的話 # 可以直接用 -- 檔案路徑 git stash -- project/module/file.xxx clean 針對那些沒有被版控的檔案，如果老是要一個一個刪就會很煩躁\n這個沒啥好筆記的，直接把可用變數列出來好了\n--dry-run -n -- only show what would and what would not be removed --exclude -e -- skip files matching specified pattern --force -f -- required when clean.requireForce is true (default) --interactive -i -- show what would be done and clean files interactively --quiet -q -- don\u0026#39;t print names of files removed -X -- remove only ignored files -d -- also remove untracked directories -x -- also remove ignored files # 強制刪除所有untracked files，而且連資料夾也會刪除 git clean -f -d 應用篇 重新命名 // 重新命名分支 git branch -m \u0026lt;oldname\u0026gt; \u0026lt;newname\u0026gt; // 重新命名當前分支 git branch -m \u0026lt;newname\u0026gt; reference\n","permalink":"/posts/article/2021-11-10-git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AD%86%E8%A8%98/","summary":"Git常用命令筆記","title":"Git常用命令筆記"},{"content":"EnterHealth EnterHealth 提供簡單易用的方式輸入健康資訊到Apple的健康之中。 讓健康資訊不再散落在各地。\n以輕鬆記錄血壓資訊為主建立的App\n因為家人有記錄血壓的需求，所以想幫他們建立一個容易閱讀、記錄的軟體。\n相關的健康資訊都會保留在Apple提供的「健康」App中\n・使用Apple的Health保存資訊，不再將健康資訊儲存在多個地方。\n・提供保存「最近刪除的記錄」讓手滑刪除後還能救得回來。\n提醒： 刪除的資訊只會保留在手機之中，並不會上傳到網路。 如果在「健康App」中刪除這些資訊，則不會被保留記錄，該檔案將會永久刪除。\n可以匯出JSON與CSV格式的檔案，可以提供給醫療人員幫忙分析。\n提供通知來提醒自己量測血壓。\n如果需要任何支援或提供建議\n歡迎來信\n","permalink":"/posts/apps/enterhealth/support/","summary":"EnterHealth support","title":"EnterHealth Support"},{"content":"EnterHealth 使用條款 EnterHealth提供記錄血壓、心律等健康數據。\n輸入的數據會儲存於Apple.Inc提供的健康 App之中。\n刪除的數據會被保存在手機本地之中， 方便搶救誤刪的資料。\n用戶可以隨時刪除這些保存的資料，這次的刪除則是永久性的。 刪除後則無法再次恢復這些資料。\n免責聲明 請用戶對於自己輸入的資料正確性負責。任何數據所衍生的問題，EnterHealth概不負責\n因為資料不會上傳，所以請用戶妥善保存這些資訊。任何數據遺失衍生的問題，EnterHealth概不負責。\n隱私權政策 EnterHealth不會使用任何用戶資料。\n所有輸入的資料都會儲存到Apple.Inc的Health中，\n你可以在任何時間透過隱私權設定拒絕EnterHealth存取Health中的資料。\nEnterHealth會保留「最近刪除的記錄」，用戶可以隨時永久性的刪除這些資訊。\n","permalink":"/posts/apps/enterhealth/terms_and_privacy_policy/","summary":"EnterHealth terms and privacy policy","title":"EnterHealth Terms"},{"content":"LooPlayer 隱私權政策 LooPlayer 是一個簡單的循環播放筆記軟體\n由LooPlayer所產生的資料會被儲存在app本地或是iCloud之中。\n無論是儲存在哪裡，這些資料都只會被你所使用。\nLooPlayer並不會搜集或使用你的任何資訊。\n","permalink":"/posts/apps/looplayer/privacy_policy/","summary":"LooPlayer support","title":"LooPlayer privacy term"},{"content":"Requestflow 隱私權政策 Requestflow 是一個純粹的網路測試工具\n由Requestflow所產生的資料會被儲存在app本地或是iCloud之中。\n無論是儲存在哪裡，這些資料都只會被你所使用。\nRequestflow並不會搜集或使用你的任何資訊。\n由於許多網站的設計並不相同，送出的資訊可能會造成資料缺失，請小心的處理你要送出的資訊。任何使用本軟體所造成的損害，Requestflow概不負責。\n","permalink":"/posts/apps/requestflow/privacy_policy/","summary":"Requestflow support","title":"Requestflow Support"},{"content":"如題，使用模擬器開發的時候，如果想要快速的從Finder或Terminal中直接存取App的資料夾的話 最快的方法就是用lldb的命令\npo NSHomeDirectory()\n只要在模擬器使用期間直接暫停（cmd + ctrl + y），讓lldb可以下命令\n就可以直接輸入上面的命令，對應的位置就會顯示出來了\nreference\n","permalink":"/posts/article/2021-11-09-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%89%BE%E5%88%B0simulator%E7%9A%84document%E4%BD%8D%E7%BD%AE/","summary":"\u003ch1 id=\"如何快速找到simulator的document位置\"\u003e如何快速找到Simulator的Document位置\u003c/h1\u003e\n","title":"如何快速找到Simulator的Document位置"},{"content":"什麼是依賴，為什麼要管理？ 任何你不能控制的物件，都是隱藏的依賴\n具體來說，如果程式完全不寫測試，那麼其實就不用考慮依賴的問題。\n要管理依賴的理由在於給測試一個介入的途徑。\n例如說有一個物件是用來追蹤聖誕老人，裡面判斷他有沒有上班。\nstruct SantaClausTracker { func isWorking() -\u0026gt; Bool { let today = Date() let month = Calendar.current.components(.month, today) let day = Calendar.current.components(.day, today) return month == 12 \u0026amp;\u0026amp; day == 25 } } 顯然，要這個方法回傳true的話，就只能在聖誕節當天進行測試。 其他日子回傳都是false。\n這個方法裡面有兩個依賴，一個是Date()，另一個則是Calendar.current。 如果想要把這些依賴變得可控，那麼就是要透過外部傳入。也就是依賴注入（dependency injection）\n傳統的方法有三：\n建構子注入 屬性注入 方法參數注入 名稱應該足以描述相對應的行為，就不多贅述了。\n換言之，在程式碼中，只要是使用的物件，都要記得可以替換。 舉個例子\n(X func somefunction() { Date() } (O func somefunction(date: Date) { date } (X func somefunction() { URLSession.share } (🔺 func somefunction(session: URLSession) { session } 那麼，顯然會出現的問題就是「依賴要怎麼來」\n例如說一個App畫面堆疊是這樣\n先不討論畫面層級太深的問題這可以看一個精彩的影片「至簡暢銷」\ngraph LR View1 --\u0026gt; View2 --\u0026gt; View3 --\u0026gt; View4 今天View4有呼叫API的需要，View2 , 3沒有。 要present View4只能夠過View3（MVC）或是View3的Coordinator（MVVM C） 勢必View2, 3都必須要攜帶一個用不到的物件。\n當今天底層越多，依賴拆分的越細，就中間的層級就容易要傳遞一些用不到的物件。\n久了就不容易維護，不容易維護就等於隱藏的Bug\n以前寫過類似的程式碼，中間傳遞的參數多了，就需要使用DTO來打包，多一層又顯得冗余。\n這時候就看到一個突破天際的想法How to control the World\n強烈建議看影片\n強烈建議看影片\n強烈建議看影片\n先來看看實作，把需要的依賴宣告在一個struct中\nstruct World { var date = { Date() } } 這邊要注意的是並不是透過「方法」來取值，例如說 func getDate() -\u0026gt; Date { ... } 因為方法的實作是不可異動的，本質上還是依賴，只是把依賴集中到一個地方管理。\n也不是直接是一個Date屬性 因為當你存取Current.date時，每次取的都是不一樣的值 如果想要每次都取得同一個時間的話，就做不到這個需求\n當然這邊也可以把這個struct改寫成protocol，然後實作不同的物件來提供不同的測試需要，不過那就是另外一回事了。\n說回正題，當你宣告了這樣的struct，你還需要一個全域的變數\nvar Current = World() 這是一個Singleton！皮諾可，這個直接電死\n別急，這時候這個設計神的地方來了。\n用上面的範例來實作的話就會變這樣\nstruct SantaClusTracker { func isWorking() -\u0026gt; Bool { //暫時先改一個，baby step let today = Current.date() let month = Calendar.current.components(.month, today) let day = Calendar.current.components(.day, today) return month == 12 \u0026amp;\u0026amp; day == 25 } } 因為Current是一個var，所以裡面的屬性是可以異動的。 因為date是一個回傳Date的function，所以實作內容也是可以異動的\n今天需要測試的時候，可以直接對Current設值。\nfunc test_Date_Is_Christmas_SantaClausTracker_isWorking_should_return_true() throws { /* 3A原則，具體可以參考91的文章或是聽他的課！獲益良多 */ //Arrange let target = SantaClausTracker() Current.date = { let formatter = DateFormatter() formatter.dateFormat = \u0026#34;yyyy/MM/dd\u0026#34; return formatter.date(string: \u0026#34;2021/12/25\u0026#34;)! } //Action let actual = target.isWorking() //Assert let expect = true XCTAssertEqual(actual, expect) } 如此，就算是在其他日子，也能檢查在聖誕節的時候是不是會回傳true\n這邊先討論幾個問題\nSingleton不是不好，為什麼要用？ 為什麼不用介面隔開？ 全域變數很危險，不應該用不是嗎？ Singleton不是不好，為什麼要用？ Singleton並不是不好，不好的話Apple還到處放不是很奇怪？\nURLSession.shared\nUserDefaults.standard\nFileManager.default\nSingleton的問題在於它是一個實體型別，無法被抽象化。也就是無法在測試中被替換。當你今天在程式碼中放了URLSession.shared以後，就註定了他一定會去走真實的網路（用intercepter擋掉另當別論），而沒辦法用MockURLSession來進行替換\n為什麼不用介面隔開？ 在看這個影片之前，我也是用protocol來進行區隔，這也有一個大神的文章可以參考歡迎來到真實世界\n先來談談如果用介面隔開URLSession，要做多少動作？\n製作一個介面URLSessionProtocol，方法簽章要跟URLSession中要呼叫的方法一致 讓URLSession擴充URLSessionProtocol，因為方法已經存在，所以不用另外實作。 製作一個測試在用的物件MockURLSession，實作介面URLSessionProtocol，裡面不涉及網路存取，直接回傳值。 將原本程式碼呼叫URLSession.shared的地方全部抽換掉 在測試中將MockURLSession注入到測試目標中 首先，這個做法對程式碼改動幅度比較大，當早期沒做，後面要抽換的時候改動幅度就會很大，也是存在風險。\n其次，如果介面裡面的方法開始變多以後，一個新的Mock物件實作起來不容易。\n例如說一個資料庫存取介面，有四個方法CRUD\n那麼建立一個新的Mock物件就要實作四個方法。\n而一個正常的介面方法都不止四個\n全域變數很危險，不應該用不是嗎？ 全域變數的危險之處在於「你不知道什麼時候被改動」\n誠然，設定為變數是存在風險的，但是不應該把Current當成是一個傳遞、暫存參數的地方。而是一個依賴保管區（Production時）、依賴注入區（Develop時）\n說回這個方法\n如果今天要測試使用者登入「成功」與「失敗」的情境\nstruct UserAPIClient { func login(account: String, password: String, complectionHandler: @escaping (Bool) -\u0026gt; Void ) { let url = URL(string: \u0026#34;API Path\u0026#34;)! // \u0026lt;-- 這裡一定run time error URLSession.shared.dataTask(with: url) { data, _, _ in complectionHandler(data == nil) } } } struct ContentView: View { @State private var loginResult: Bool = false var body: some View { Text(\u0026#34;Login \\(loginResult ? \u0026#34;Success\u0026#34; : \u0026#34;Failure\u0026#34;)\u0026#34;) .onAppear { UserAPIClient().login(account: \u0026#34;account\u0026#34;, password: \u0026#34;password\u0026#34;) { result in loginResult = result } } } } UserAPIClient有一個一定會在run time炸掉的地方，那就是URL(string: \u0026quot;API Path\u0026quot;)!\n假想這是Server暫時不可用，或是網路斷線的情境吧。\n那這種時候就不用測試了嗎？沒錯！後台修好再叫我\n當然不可能，所以這時候就需要脫離實際環境來測試功能是否正常。\n用protocol的方式來進行脫鉤是這樣實作的\n//1. 定義協議 protocol UserAPIClientProtocol { func login(account: String, password: String, complectionHandler: @escaping (Bool) -\u0026gt; Void ) } //2. 讓原本的物件擴充這個協議 extension UserAPIClient: UserAPIClientProtocol { } //3. 建立測試物件，因為測試情境有「成功」「失敗」，所以回傳值用建構注入 struct MockUserAPIClient: UserAPIClientProtocol { var loginResult: Bool func login(account: String, password: String, complectionHandler: @escaping (Bool) -\u0026gt; Void ) { complectionHandler(loginResult) } } //4. 將原本的型別用介面抽換（呼叫的時候要注入） struct ContentView: View { var userAPIClient: UserAPIClientProtocol @State private var loginResult: Bool = false var body: some View { Text(\u0026#34;Login \\(loginResult ? \u0026#34;Success\u0026#34; : \u0026#34;Failure\u0026#34;)\u0026#34;) .onAppear { userAPIClient.login(account: \u0026#34;acc\u0026#34;, password: \u0026#34;pass\u0026#34;) { result in loginResult = result } } } } //5. 修改呼叫端 struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView(userAPIClient: MockUserAPIClient(loginResult: true)) } } 如果用World來控制的話，是這個樣子的\nstruct UserAPI { var login = UserAPIClient().login(account:password:complectionHandler:) } struct World { var userAPI = UserAPI() } var Current = World() struct ContentView: View { @State private var loginResult: Bool = false var body: some View { Text(\u0026#34;Login \\(loginResult ? \u0026#34;Success\u0026#34; : \u0026#34;Failure\u0026#34;)\u0026#34;) .onAppear { Current.userAPI.login(\u0026#34;account\u0026#34;, \u0026#34;password\u0026#34;) { result in loginResult = result } } } } //修改呼叫端 struct ContentView_Previews: PreviewProvider { static var previews: some View { //正常不會在這邊修改，這邊只是懶得把資料切乾淨所以放著舉例一下 Current.userAPI.login = { _, _, callback in callback(true) } return ContentView() } } 看起來有點差異，但是好像又差異不大？ 當你再遇到這樣的需求時\ngraph LR View1 --\u0026gt; View2 --\u0026gt; View3 --\u0026gt; View4 View2, 3就不需要攜帶UserAPIClient跑來跑去了\n最重要的是 當你的測試情境需要不同的回傳值時，不再需要像上面的MockUserAPIClient一樣透過各種注入，考慮各種測試情境要呼叫方法時的通用性，而是可以直接針對特定方法改寫方法實作內容。\n參考文章： https://vimeo.com/291588126\nhttps://www.codementor.io/koromiko/unit-test-for-networking-ahdpdqr5k\n","permalink":"/posts/article/2021-10-11-%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A8%AE%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BE%9D%E8%B3%B4%E6%8E%A7%E5%88%B6/","summary":"什麼是依賴，為什麼要管理？ 任何你不能控制的物件，都是隱藏的依賴\n具體來說，如果程式完全不寫測試，那麼其實就不用考慮依賴的問題。\n要管理依賴的理由在於給測試一個介入的途徑。\n例如說有一個物件是用來追蹤聖誕老人，裡面判斷他有沒有上班。\nstruct SantaClausTracker { func isWorking() -\u0026gt; Bool { let today = Date() let month = Calendar.current.components(.month, today) let day = Calendar.current.components(.day, today) return month == 12 \u0026amp;\u0026amp; day == 25 } } 顯然，要這個方法回傳true的話，就只能在聖誕節當天進行測試。 其他日子回傳都是false。\n這個方法裡面有兩個依賴，一個是Date()，另一個則是Calendar.current。 如果想要把這些依賴變得可控，那麼就是要透過外部傳入。也就是依賴注入（dependency injection）\n傳統的方法有三：\n建構子注入 屬性注入 方法參數注入 名稱應該足以描述相對應的行為，就不多贅述了。\n換言之，在程式碼中，只要是使用的物件，都要記得可以替換。 舉個例子\n(X func somefunction() { Date() } (O func somefunction(date: Date) { date } (X func somefunction() { URLSession.share } (🔺 func somefunction(session: URLSession) { session } 那麼，顯然會出現的問題就是「依賴要怎麼來」","title":"另外一種方式的依賴控制"},{"content":"關於GCD 什麼是GCD？GCD的全名為Grand Central Dispatch\n基本上就是執行緒管理中心。用比較不嚴謹的敘述來說的話，它就是幫助你處理多執行緒的管理器。 利用GCD，可以很方便地操控各種需要多執行緒的情境\nGCD的運作原理 這邊姑且先不討論程式面的東西，先從抽象一點的地方來看。\n基本上來說，GCD掌控了Queue，而Queue包含了Work Item，最後WorkItem就是要執行的Closure\nQueue Queue可以被翻成「佇列」，但是看了翻譯還是不知道是什麼意思。\n可以想像成是去看電影的時候排隊的人潮，隊伍本身就是Queue。\n先排進去的人，就可以先買票。這就是 FIFO ( First In First Out ) 的概念。\nQueue裡面放的是WorkItem，用買票的例子來解釋的話，就是你要買哪場的票這件事。\nQueue又有分Serial跟Concurrent兩種\nSerial：就是一次只執行一個WorkItem，在這個WorkItem還沒執行完之前，不會取下一個來執行。\nConcurrent：自然就是相對於Serial，當第一個WorkItem被取出後，並不會等這個WorkItem被執行完，就接著取出下一個WorkItem，一直到這個Queue中所有WorkItem被拿出來執行為止（或是你吃光了所有系統可分配的Thread，也會被暫停）\n講完了Queue的類型，再來就是Queue要怎麼執行WorkItem\n這部分就分為 Sync（同步）跟Async（非同步） 兩種\nSync：\n當前的Queue會被擋住，不能往下執行，等待WorkItem被執行完以後，才會繼續往下執行。在這個時間點中只有一個Queue可以運作。\n所以在用sync方法的時候一定要非常小心一個重點\n如果當前的執行中的Queue是Serial，而且你又要拿來做sync的動作的話，就會造成Deadlock\n舉個例子，下面這段程式如果用Main Queue來執行，就永遠不會執行到print\nDispatchQueue.main.sync { print(\u0026#34;never execute here\u0026#34;) } 發生的原因很簡單，因為當系統執行到DispatchQueue.main.sync這段的時候，系統就知道「阿，要塞住當前的Queue」也就是MainQueue，然後又叫MainQueue去做事。但是這時候Main Queue已經被塞住了，又怎麼能去print呢？\nAsync：非同步代表的是它不會塞住當前的執行緒 所以當Queue用非同步去執行WorkItem的時候，系統會開一條新的Thread去執行這個WorkItem，然後就繼續往下執行。\n非同步程式可以保證當前的Thread執行不會被卡住，因為都會開一個新的Thread去執行WorkItem。但是非同步程式常常會遇到的就是他不會有返回值，所以很容易出現Callback Hell的狀況。不過這不是本篇要講的重點，後面寫PromiseKit或RxSwift的時候再說。\n舉幾個例子，這可以直接貼到Playground裡面來執行\nfunc syncDemo() { print(\u0026#34;do something before sync\u0026#34;) DispatchQueue.global().sync { for _ in 0...5 { print(\u0026#34;sync\u0026#34;) } } print(\u0026#34;do something after sync\u0026#34;) } syncDemo() 結果是比較顯而易見的，就跟程式執行順序一致。\ndo something before sync sync sync sync sync sync sync do something after sync 那麼用差不多的架構，只不過把sync換成async的話，會怎麼樣的？\nfunc asyncDemo() { print(\u0026#34;do something before async\u0026#34;) DispatchQueue.global().async { // \u0026lt;-- 注意這裡是async for _ in 0...5 { print(\u0026#34;async\u0026#34;) } } print(\u0026#34;do something after async\u0026#34;) } asyncDemo() 這邊就差很多了。\n因為是另外開執行緒去做事，所以跟看到的結果就會有明顯差異\ndo something before async do something after async async async async async async async 所以關於怎麼挑選自己要用的Queue，就可以從這四個裡面去兜出來。\n具體的挑選就看自己的情境來決定。\n本來還要寫一些DispatchGroup、訊號機等筆記的，但是寫的有點煩了。\n要改的東西太多了，那麼就改天吧。\n","permalink":"/posts/article/2020-06-29-gcd%E7%AD%86%E8%A8%98-01/","summary":"關於GCD的一些筆記","title":"關於GCD的一些筆記-1"},{"content":"最近電腦爆了，懷疑應該是副廠的線造成的問題，\n看樣子東西真的不能買便宜的（？\n剛好也想說順便重新設定一些環境上的東西，只是這次要認真的寫筆記了\u0026hellip;\n之前的筆記都非常的零碎，重看的時候才會覺得好像少了很多東西。\n身為一個軟體工程師，寫一些坑人的筆記也是理所當然的事。\n正文開始\nssh到GitHub的時候，使用私鑰進行驗證 具體步驟大概分為\n產生rsa的公私鑰 設定ssh的config （optional） 登入Github並且加入剛剛產生的公鑰 （手動） 測試連線 產生rsa的公私鑰 ssh-keygen 過程中會問兩個問題\n產生的公私鑰要放的位置 設定密碼 ( passphrase ) 公私鑰的位置如果直接按Return的話，就會存在預設的位置。\n預設位置為：/Users/username/.ssh/id_rsa\n這邊的username請自行修改成你的帳號，不是真的路徑喔\u0026hellip;\n不然也可以自行輸入要存放的位置，例如：\n/Users/username/.ssh/rsa-for-github\n不過這邊要留意一點：不能用tab自動補全，在輸入的時候要注意大小寫跟拼字\n密碼的部分應該是為了多人共用電腦而設計的，避免使用別人的私鑰去亂搞。\n如果輸入密碼的話就每次使用ssh連接時都需要打密碼。\n這部分我就沒特別研究了，有需要的請自行研究。\n完成以後會產生一組公私鑰檔案，例如\nrsa-for-github.pub and rsa-for-github\n沒有.pub的檔案就是私鑰，請好好保管。\n設定ssh的config 如果在第一步中使用預設位置的話，這一步就可以跳過，如果還有興趣就隨便看看吧\n用不同鑰匙的好處，就跟你不同網站用不同密碼是一樣的概念，\n減少私鑰遺失後全部都被攻破的風險。\n缺點當然是要自行管理這些檔案，管理的方法就是用config來告訴ssh要用哪一個私鑰來驗證。\n因為預設的ssh會去讀id_rsa作為私鑰去驗證，所以如果不用config讓ssh知道要用哪一把鑰匙去做驗證，不管怎麼都入都是失敗的喔。\n基本上我常用的大概就幾個\nHost # 用來連線的 alias 名稱 HostName # host domain 或 ip Port # host 的 SSH port IdentityFile # 私鑰位置 User # 登入帳號 舉幾個例子：\n# Github Host github.com HostName github.com IdentityFile ~/.ssh/rsa_for_github User git # Raspberry # 因為我有買樹莓派回來玩，如果不用這樣登入的話，每次都是要打帳號密碼，很煩。 Host raspbian HostName 192.168.1.123 IdentityFile ~/.ssh/rsa_for_rpi User pi 登入Github並且加入剛剛產生的公鑰 可以先用cat指令來顯示公鑰內容，然後再把公鑰貼到Github的SSH Key欄位中\n這邊比較簡單就放三張圖自己研究一下就夠了。\n這邊補充一下，如果要用命令將公鑰加入到目標server中的話（例如樹莓派）可以用以下的命令來執行。\n不確定能不能用命令把公鑰加入到Github中，這部分沒特別研究。\n# 語法： ssh-copy-id user@host # 如果不是用預設的名稱，就要加入參數 i，用來指定IdentityFile ssh-copy-id -i ~/.ssh/rsa-for-rpi.pub user@host # 範例 ssh-copy-id pi@192.168.1.123 ssh-copy-id -i ~/.ssh/rsa-for-rpi.pub pi@192.168.1.123 測試連線 根據Github的線上文件，只要透過下面這行命令即可\nssh -T git@github.com 只要最後出現的是下面這樣就算成功了，至於沒出現的話，就看看有哪些地方做錯了吧。\n\u0026gt; Hi username! You\u0026#39;ve successfully authenticated, but GitHub does not \u0026gt; provide shell access. 參考網頁 https://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/\nhttps://xenby.com/b/220-教學-產生ssh-key並且透過key進行免密碼登入\nhttps://help.github.com/en/github/authenticating-to-github/testing-your-ssh-connection\n","permalink":"/posts/article/2020-06-28-ssh-%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A/","summary":"ssh到GitHub的時候，使用私鑰進行驗證","title":"SSH 基本設定"},{"content":"","permalink":"/posts/article/2020-06-28-hello-world/","summary":"Hello Hugo","title":"Hello World"},{"content":"用Aido \u0026amp; Aido baby的例子來說明抽象化的概念\n","permalink":"/drafts/2022-06-20-%E5%B7%A5%E7%A8%8B%E5%B8%AB%E6%87%89%E8%A9%B2%E5%85%B7%E5%82%99%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%8C%96%E6%A6%82%E5%BF%B5/","summary":"用Aido \u0026amp; Aido baby的例子來說明抽象化的概念","title":""},{"content":"JSON 開發觀念 不要用underline之類的方式來作為JSON的key\n如果有多個底線相關的key，就應該考慮用object封裝起來。\n{ \u0026#34;SomeKeyTitle\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;SomeKeyNote\u0026#34;: { \u0026#34;SomeKeyArray\u0026#34;: [ { \u0026#34;someKey_node_id\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;someKey_list_id\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey_type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey_time\u0026#34;: \u0026#34;Value\u0026#34;, } ] }, } 改成\n{ \u0026#34;SomeKey\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Notes\u0026#34;: { \u0026#34;Array\u0026#34;: [ { \u0026#34;nodeId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;listId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;Value\u0026#34; } } ] } } } 既然一個物件裡面只裝著陣列，那爲什麼不直接抽出來將Value作為陣列？ { \u0026#34;SomeKey\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Notes\u0026#34;: [ { \u0026#34;nodeId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;listId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;Value\u0026#34; } }, { xxx } ] } } ","permalink":"/drafts/data-model/","summary":"JSON 開發觀念 不要用underline之類的方式來作為JSON的key\n如果有多個底線相關的key，就應該考慮用object封裝起來。\n{ \u0026#34;SomeKeyTitle\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;SomeKeyNote\u0026#34;: { \u0026#34;SomeKeyArray\u0026#34;: [ { \u0026#34;someKey_node_id\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;someKey_list_id\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey_type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey_time\u0026#34;: \u0026#34;Value\u0026#34;, } ] }, } 改成\n{ \u0026#34;SomeKey\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Notes\u0026#34;: { \u0026#34;Array\u0026#34;: [ { \u0026#34;nodeId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;listId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;Value\u0026#34; } } ] } } } 既然一個物件裡面只裝著陣列，那爲什麼不直接抽出來將Value作為陣列？ { \u0026#34;SomeKey\u0026#34;: { \u0026#34;Title\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Notes\u0026#34;: [ { \u0026#34;nodeId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;listId\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;otherKey\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Value\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;Value\u0026#34; } }, { xxx } ] } } ","title":""},{"content":"Gitbook架設 Part 1 根據目前查到的資料，似乎線上版有一些微微妙妙的問題， 所以這邊打算採用自己架設的做法。\n因為文件都散落在各個MD檔之中，想說要找找一個方便地管理工具 有很多東西因為以前比較少碰到，所以也算是粗略做個記錄。\n以下是踩坑過程。\n安裝yarn 要安裝Gitbook的時候，網路上搜尋到的是用npm來安裝。 然後莫名的就搜尋到新的管理工具yarn\n秉持著有新的就用新的原則，就學著用新的工具來安裝看看。\nbrew install yarn 然後就是安裝gitbook套件\nyarn global add gitbook gitbook-cli 因為有很多地方都打算導入gitbook來管理文件，所以就選用global\nnode 與 nvm 然後按照教學輸入\ngitbook init 之後就就很順利地炸了。error log如下\nwarn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \u0026#34;data\u0026#34; argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 發現是node的版本太新，可以用node -v來檢查當前的node版本。\n於是就開始研究nvm的使用方式。\nnvm: 管理Node版本的工具 使用homebrew來安裝nvm\nbrew install nvm 安裝成功後有一些環境變數要設定到.zshrc(或是.bashrc中) 全部處理完成以後就可以使用nvm來管理node\nnvm ls-remote nvm install v13.14.0 nvm use v13.14.0 詳細的nvm指令與功能就另外開一篇來寫好了，就不在這邊多說了。\n切換node版本以後就可以順利執行了\n再次輸入：\ngitbook init 會產生一個SUMMARY.md檔，這是左側的目錄\n裡面也是使用markdown的超連結方式進行撰寫\n路徑的部分還沒想好應該要怎麼部，就先做個測試版吧。\n# Summary * [Introduction](README.md) * [Test1](test1/test1.md) * [Test2](test2/test2.md) * [Sub2](test2/test2-2.md) 第一部分就先寫個架設篇， 後面真的用起來了再來寫第二部分。\nReference Gitbook in yarn Gitbook-CLI in yarn 參考 參考 參考 ","permalink":"/drafts/gitbook%E6%9E%B6%E8%A8%AD%E9%81%8E%E7%A8%8B/","summary":"Gitbook架設 Part 1 根據目前查到的資料，似乎線上版有一些微微妙妙的問題， 所以這邊打算採用自己架設的做法。\n因為文件都散落在各個MD檔之中，想說要找找一個方便地管理工具 有很多東西因為以前比較少碰到，所以也算是粗略做個記錄。\n以下是踩坑過程。\n安裝yarn 要安裝Gitbook的時候，網路上搜尋到的是用npm來安裝。 然後莫名的就搜尋到新的管理工具yarn\n秉持著有新的就用新的原則，就學著用新的工具來安裝看看。\nbrew install yarn 然後就是安裝gitbook套件\nyarn global add gitbook gitbook-cli 因為有很多地方都打算導入gitbook來管理文件，所以就選用global\nnode 與 nvm 然後按照教學輸入\ngitbook init 之後就就很順利地炸了。error log如下\nwarn: no summary file in this book info: create SUMMARY.md TypeError [ERR_INVALID_ARG_TYPE]: The \u0026#34;data\u0026#34; argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received an instance of Promise 發現是node的版本太新，可以用node -v來檢查當前的node版本。\n於是就開始研究nvm的使用方式。\nnvm: 管理Node版本的工具 使用homebrew來安裝nvm\nbrew install nvm 安裝成功後有一些環境變數要設定到.","title":""},{"content":"要放權限給使用者（帳號），不然會查不到。 GRANT ALL PRIVILEGES ON databaseName.tableName ( or * ) TO \u0026lsquo;username\u0026rsquo;@\u0026lsquo;host\u0026rsquo;;\n","permalink":"/drafts/mysql/","summary":"要放權限給使用者（帳號），不然會查不到。 GRANT ALL PRIVILEGES ON databaseName.tableName ( or * ) TO \u0026lsquo;username\u0026rsquo;@\u0026lsquo;host\u0026rsquo;;","title":""},{"content":"Node \u0026amp; NVM // 檢查線上版本 nvm ls-remote // 安裝node // 安裝特定版本 nvm install v13.14.0 // 安裝穩定版 nvm install stable // 檢查已經安裝過的node列表 nvm ls // 移除node nvm uninstall v14.19.2 // 切換版本 nvm use v13.14.0 NPM yarn\nnpm\npackage.json\npackage-lock.json\nRef https://medium.com/哆啦實驗室/node-js管理神器nvm-b6acfca44ea5 https://segmentfault.com/a/1190000019037664 https://blog.csdn.net/zheng18237111686/article/details/113878602\nnpm http://dreamerslab.com/blog/tw/npm-basic-commands/\nyarn https://segmentfault.com/a/1190000008489881 https://simpleit.rocks/javascript/yarn/how-to-search-packages-using-yarn/ https://yarnpkg.com/cli/init https://ithelp.ithome.com.tw/articles/10191888 https://ithelp.ithome.com.tw/articles/10191745 http://nodejs.cn/learn/the-package-json-guide\nLTS Long Time Support Node https://www.796t.com/post/bG80Ng==.html\n","permalink":"/drafts/nvm/","summary":"Node \u0026amp; NVM // 檢查線上版本 nvm ls-remote // 安裝node // 安裝特定版本 nvm install v13.14.0 // 安裝穩定版 nvm install stable // 檢查已經安裝過的node列表 nvm ls // 移除node nvm uninstall v14.19.2 // 切換版本 nvm use v13.14.0 NPM yarn\nnpm\npackage.json\npackage-lock.json\nRef https://medium.com/哆啦實驗室/node-js管理神器nvm-b6acfca44ea5 https://segmentfault.com/a/1190000019037664 https://blog.csdn.net/zheng18237111686/article/details/113878602\nnpm http://dreamerslab.com/blog/tw/npm-basic-commands/\nyarn https://segmentfault.com/a/1190000008489881 https://simpleit.rocks/javascript/yarn/how-to-search-packages-using-yarn/ https://yarnpkg.com/cli/init https://ithelp.ithome.com.tw/articles/10191888 https://ithelp.ithome.com.tw/articles/10191745 http://nodejs.cn/learn/the-package-json-guide\nLTS Long Time Support Node https://www.796t.com/post/bG80Ng==.html","title":""},{"content":"Extension for Protocol 先說結論： 善用protocol來實作一些功能\nTodo: [WWDC talk 連結]\n在傳統的OOP觀念中，基本上要最小化程式碼重複的方法就是透過繼承。\nSwift 是針對 protocol 來設計的 ","permalink":"/drafts/protocol-extension-/","summary":"Extension for Protocol 先說結論： 善用protocol來實作一些功能\nTodo: [WWDC talk 連結]\n在傳統的OOP觀念中，基本上要最小化程式碼重複的方法就是透過繼承。\nSwift 是針對 protocol 來設計的 ","title":""},{"content":"Redux in SwiftUI 透過泛型來限制型別\n針對sub-view的資料處理 sub-state \u0026amp; sub-action \u0026amp; sub-reducer Store derived View -\u0026gt; sub-view 的 Connector ","permalink":"/drafts/redux-in-swift/","summary":"Redux in SwiftUI 透過泛型來限制型別\n針對sub-view的資料處理 sub-state \u0026amp; sub-action \u0026amp; sub-reducer Store derived View -\u0026gt; sub-view 的 Connector ","title":""},{"content":"檢查MacBook的SSD使用狀況 sudo smartctl —all /dev/disk0\n","permalink":"/drafts/shell-command/","summary":"檢查MacBook的SSD使用狀況 sudo smartctl —all /dev/disk0","title":""},{"content":"","permalink":"/drafts/swiftui%E7%9A%84identifiable-equable/","summary":"","title":""},{"content":"Terms of Use EnterHealth (following call \u0026ldquo;Eh\u0026rdquo; or \u0026ldquo;we\u0026rdquo;) provide to read and write blood pressure, heart rate, etc. health record from Apple.Inc Health app. (following call \u0026ldquo;Health app\u0026rdquo;)\nAll that data will store in Health app\nWhen you delete record in Eh, we will backup that record in local to make sure you can restore it any time.\nIf you don\u0026rsquo;t want to restore this record you can delete permanently. There no way to restore it again.\nDisclaimer You should confirm data is correct by youself, Eh won\u0026rsquo;t check data is reasonable or not.\nAll data is keeping in \u0026ldquo;Health app\u0026rdquo; and local. Keep it safe by youself.i\nWe don’t make any other commitments about record.\nPrivacy Policy Collected Information\nEnterHealth itself does not collect any information.\nHowever EnterHealth will keep data which you delete in Eh.\nyou can delete permanently any time.\n","permalink":"/drafts/%E4%BD%BF%E7%94%A8%E6%A2%9D%E6%AC%BE-%E8%8B%B1%E6%96%87%E7%89%88/","summary":"Terms of Use EnterHealth (following call \u0026ldquo;Eh\u0026rdquo; or \u0026ldquo;we\u0026rdquo;) provide to read and write blood pressure, heart rate, etc. health record from Apple.Inc Health app. (following call \u0026ldquo;Health app\u0026rdquo;)\nAll that data will store in Health app\nWhen you delete record in Eh, we will backup that record in local to make sure you can restore it any time.\nIf you don\u0026rsquo;t want to restore this record you can delete permanently.","title":""},{"content":" 例如說常在SwiftUI List, ForEach裡面用到的Identifiable， 每次要做比較的時候都要寫一次Equable的等價關係\n如果善用protocol extenion的話，就可以針對大部分的Identifiable做一個通用的擴充\n所有實作了Identifiable的對象都可以直接擴充Equable，而不用再寫同樣的程式碼\nextension Equable where Self: Identifiable { static func == (lhs: Environment, rhs: Environment) -\u0026gt; Bool { lhs.id == rhs.id } } 如果有不一樣的需求，再自己實作一次介面方法就可以了。\n","permalink":"/drafts/%E5%96%84%E7%94%A8protocol%E8%88%87protocol-extension/","summary":"例如說常在SwiftUI List, ForEach裡面用到的Identifiable， 每次要做比較的時候都要寫一次Equable的等價關係\n如果善用protocol extenion的話，就可以針對大部分的Identifiable做一個通用的擴充\n所有實作了Identifiable的對象都可以直接擴充Equable，而不用再寫同樣的程式碼\nextension Equable where Self: Identifiable { static func == (lhs: Environment, rhs: Environment) -\u0026gt; Bool { lhs.id == rhs.id } } 如果有不一樣的需求，再自己實作一次介面方法就可以了。","title":""},{"content":"https://stackoverflow.com/questions/1783405/how-do-i-check-out-a-remote-git-branch\nhttps://en.wikipedia.org/wiki/GraalVM\nhttps://www.zhihu.com/question/430792464\nhttps://benjr.tw/98233\nhttps://www.cnblogs.com/xiaowuzi/p/3485302.html\nhttps://docs.spring.io/spring-data/jpa/docs/current/reference/html/\n","permalink":"/drafts/%E6%9C%AA%E5%91%BD%E5%90%8D-3/","summary":"https://stackoverflow.com/questions/1783405/how-do-i-check-out-a-remote-git-branch\nhttps://en.wikipedia.org/wiki/GraalVM\nhttps://www.zhihu.com/question/430792464\nhttps://benjr.tw/98233\nhttps://www.cnblogs.com/xiaowuzi/p/3485302.html\nhttps://docs.spring.io/spring-data/jpa/docs/current/reference/html/","title":""},{"content":"Git rename remote branch Git checkout -b localBranchname origin/remoteBranchName Git push origin \u0026ndash;delete remoteBranchName Git push origin -u localBranchName OR 尚未測試過\nGit push origin : remoteBranchName newBranchName Git push origin -u newBranchName ","permalink":"/memo/git-%E9%87%8D%E6%96%B0%E5%91%BD%E5%90%8D%E9%81%A0%E7%AB%AF%E5%88%86%E6%94%AF/","summary":"Git rename remote branch Git checkout -b localBranchname origin/remoteBranchName Git push origin \u0026ndash;delete remoteBranchName Git push origin -u localBranchName OR 尚未測試過\nGit push origin : remoteBranchName newBranchName Git push origin -u newBranchName ","title":""},{"content":"Git 主幹名稱 因為SJW的不懈努力，git的主幹名稱從master改成main了\n如果是早期的config還是使用master的命名的話，git會建議你更換名稱。\n更換git預設的主幹名稱\ngit config \u0026ndash;global init.defaultBranch \u0026lt;#NewMainBranchName#\u0026gt;\n更換當前主幹/分支名稱\ngit branch -m main\n","permalink":"/memo/git-command/","summary":"Git 主幹名稱 因為SJW的不懈努力，git的主幹名稱從master改成main了\n如果是早期的config還是使用master的命名的話，git會建議你更換名稱。\n更換git預設的主幹名稱\ngit config \u0026ndash;global init.defaultBranch \u0026lt;#NewMainBranchName#\u0026gt;\n更換當前主幹/分支名稱\ngit branch -m main","title":""},{"content":"Git 在Github上設定personal access token 如果要做git clone的時候，要用https下載 這時候要打密碼，如果不記起來的話密碼可能就不能用第二次了。 # 要記憶密碼的話 git config --global credential.helper cache # 如果要清除掉設定的話 git config --global --unset credential.helper ","permalink":"/memo/git%E4%BD%BF%E7%94%A8personalaccesstoken/","summary":"Git 在Github上設定personal access token 如果要做git clone的時候，要用https下載 這時候要打密碼，如果不記起來的話密碼可能就不能用第二次了。 # 要記憶密碼的話 git config --global credential.helper cache # 如果要清除掉設定的話 git config --global --unset credential.helper ","title":""},{"content":"","permalink":"/memo/%E5%B0%8E%E5%85%A5swiftlint/","summary":"","title":""},{"content":"xcodebuild test -project WebScraper.proj -scheme WebScraperTests -destination \u0026ldquo;platform=iOS Simulator,OS=15.1,name=iPhone 8\u0026rdquo; -enable xcodebuild -project WebScraper.xcodeproj -scheme WebScraper -destination \u0026ldquo;platform=iOS Simulator,name=iPhone 8,OS=15.2\u0026rdquo; -enableCodeCoverage YES test\n// view xcresult\nbrew install XCTestHtmlReport/xchtmlreport/xchtmlreport ","permalink":"/memo/%E7%94%A8terminal%E5%9F%B7%E8%A1%8Cxcode%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/","summary":"xcodebuild test -project WebScraper.proj -scheme WebScraperTests -destination \u0026ldquo;platform=iOS Simulator,OS=15.1,name=iPhone 8\u0026rdquo; -enable xcodebuild -project WebScraper.xcodeproj -scheme WebScraper -destination \u0026ldquo;platform=iOS Simulator,name=iPhone 8,OS=15.2\u0026rdquo; -enableCodeCoverage YES test\n// view xcresult\nbrew install XCTestHtmlReport/xchtmlreport/xchtmlreport ","title":""},{"content":"關於ssh登入這回事 交接資料中有許多東西都是與帳號密碼相關， 但是在交接資料中可以看到帳號密碼是一件非常詭異的事情。\n這就讓我去思考遠端連線到底應該要怎麼做才會是正確的。\n帳號跟密碼只應該由MIS保留，且取得需要有相關授權之類的\nMIS應該負責創建使用者的RSA金鑰\n由MIS負責配發金鑰，讓使用者能夠進行連線或是相關操作。\n當同事離職以後，也應該由MIS負責將對應的金鑰從遠端機器中刪除。\n","permalink":"/memo/%E9%97%9C%E6%96%BCssh%E7%99%BB%E5%85%A5%E9%80%99%E5%9B%9E%E4%BA%8B/","summary":"關於ssh登入這回事 交接資料中有許多東西都是與帳號密碼相關， 但是在交接資料中可以看到帳號密碼是一件非常詭異的事情。\n這就讓我去思考遠端連線到底應該要怎麼做才會是正確的。\n帳號跟密碼只應該由MIS保留，且取得需要有相關授權之類的\nMIS應該負責創建使用者的RSA金鑰\n由MIS負責配發金鑰，讓使用者能夠進行連線或是相關操作。\n當同事離職以後，也應該由MIS負責將對應的金鑰從遠端機器中刪除。","title":""}]